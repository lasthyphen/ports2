import*as e from"cache-parser";import*as t from"fast-defer";import*as a from"object-code";var r={d:(e,t)=>{for(var a in t)r.o(t,a)&&!r.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},s={};r.d(s,{h4:()=>n,UN:()=>A,uu:()=>S,Kd:()=>v,ZF:()=>M,nv:()=>I,p:()=>g,E7:()=>c,NQ:()=>o,xK:()=>E,G6:()=>h,LN:()=>m,Bw:()=>y,Ad:()=>u,$k:()=>b,v8:()=>T,Jk:()=>l,tI:()=>p,iS:()=>f});const i=(e=>{var t={};return r.d(t,e),t})({parse:()=>e.parse}),n=Object.freeze({IfModifiedSince:"if-modified-since",LastModified:"last-modified",IfNoneMatch:"if-none-match",CacheControl:"cache-control",ETag:"etag",Expires:"expires",Age:"age",XAxiosCacheEtag:"x-axios-cache-etag",XAxiosCacheLastModified:"x-axios-cache-last-modified",XAxiosCacheStaleIfError:"x-axios-cache-stale-if-error"}),o=e=>{if(!e)return"not enough headers";const t=e[n.CacheControl];if(t){const{noCache:a,noStore:r,mustRevalidate:s,maxAge:o,immutable:d}=(0,i.parse)(String(t));if(a||r)return"dont cache";if(d)return 31536e6;if(s)return 0;if(o){const t=e[n.Age];return t?1e3*(o-Number(t)):1e3*o}}const a=e[n.Expires];if(a){const e=Date.parse(String(a))-Date.now();return e>=0?e:"dont cache"}return"not enough headers"};const d=(e=>{var t={};return r.d(t,e),t})({deferred:()=>t.deferred});function c(e){return e?t=>e(t)||304===t:e=>e>=200&&e<300||304===e}function u(e="get",t=[]){e=e.toLowerCase();for(const a of t)if(a.toLowerCase()===e)return!0;return!1}function f(e,t){t.headers||(t.headers={});const{etag:a,modifiedSince:r}=t.cache;if(a){const r=!0===a?e.data?.headers[n.ETag]:a;r&&(t.headers[n.IfNoneMatch]=r)}r&&(t.headers[n.IfModifiedSince]=!0===r?e.data.headers[n.LastModified]||new Date(e.createdAt).toUTCString():r.toUTCString())}function g(e,t){return 304===e.status&&t?(e.cached=!0,e.data=t.data,e.status=t.status,e.statusText=t.statusText,e.headers={...t.headers,...e.headers},t):{data:e.data,status:e.status,statusText:e.statusText,headers:e.headers}}function h(e){const t=async t=>{if(!1===t.cache)return e.debug?.({msg:"Ignoring cache because config.cache is false",data:t}),t;if(t.cache={...e.defaults.cache,...t.cache},!u(t.method,t.cache.methods))return e.debug?.({msg:`Ignored because method (${t.method}) is not in cache.methods (${t.cache.methods})`}),t;const a=t.id=e.generateKey(t);let r,s=await e.storage.get(a);e:if("empty"===s.state||"stale"===s.state){if(e.waiting[a]){s=await e.storage.get(a),e.debug?.({id:a,msg:"Waiting list had an deferred for this key, waiting for it to finish"});break e}return e.waiting[a]=(0,d.deferred)(),e.waiting[a]?.catch((()=>{})),await e.storage.set(a,{state:"loading",previous:s.state,data:s.data,createdAt:s.createdAt}),"stale"===s.state&&(f(s,t),e.debug?.({id:a,msg:"Updated stale request"})),t.validateStatus=c(t.validateStatus),e.debug?.({id:a,msg:"Sending request, waiting for response"}),t}if("loading"===s.state){const s=e.waiting[a];if(!s)return await e.storage.remove(a),t;e.debug?.({id:a,msg:"Detected concurrent request, waiting for it to finish"});try{r=await s}catch(r){return e.debug?.({id:a,msg:"Deferred rejected, requesting again",data:r}),t}}else r=s.data;return t.adapter=()=>Promise.resolve({config:t,data:r.data,headers:r.headers,status:r.status,statusText:r.statusText,cached:!0,id:a}),e.debug?.({id:a,msg:"Returning cached response"}),t};return{onFulfilled:t,apply:()=>e.interceptors.request.use(t)}}async function l(e,t){if("function"==typeof t)return t(e);const{statusCheck:a,responseMatch:r,containsHeaders:s}=t;if(a&&!await a(e.status)||r&&!await r(e))return!1;if(s)for(const t in s){const a=s[t];if(a&&!await a(e.headers[t.toLowerCase()]??e.headers[t]))return!1}return!0}async function p(e,t,a){for(const r in a){const s=a[r];if("delete"===s){await e.remove(r);continue}const i=await e.get(r);if("loading"===i.state)continue;const n=await s(i,t);"delete"!==n?"ignore"!==n&&await e.set(r,n):await e.remove(r)}}function m(e){const t=async t=>{await e.storage.remove(t),e.waiting[t]?.reject(null),delete e.waiting[t]},a=async a=>{var r;if(a.id=(r=a.config).id??(r.id=e.generateKey(a.config)),a.cached??(a.cached=!1),a.cached)return e.debug?.({id:a.id,msg:"Returned cached response"}),a;if(!a.config.cache)return e.debug?.({id:a.id,msg:"Response with config.cache === false",data:a}),{...a,cached:!1};const s=a.config.cache,i=await e.storage.get(a.id);if("stale"===i.state||"empty"===i.state||"cached"===i.state)return e.debug?.({id:a.id,msg:"Response not cached but storage is not loading",data:{cache:i,response:a}}),a;if(!i.data&&!await l(a,s.cachePredicate))return await t(a.id),e.debug?.({id:a.id,msg:"Cache predicate rejected this response"}),a;for(const e in n)e.startsWith("XAxiosCache")&&delete a.headers[e];s.etag&&!0!==s.etag&&(a.headers[n.XAxiosCacheEtag]=s.etag),s.modifiedSince&&(a.headers[n.XAxiosCacheLastModified]=!0===s.modifiedSince?"use-cache-timestamp":s.modifiedSince.toUTCString());let o=s.ttl||-1;if(s?.interpretHeader){const r=e.headerInterpreter(a.headers);if("dont cache"===r)return await t(a.id),e.debug?.({id:a.id,msg:"Cache header interpreted as 'dont cache'",data:{cache:i,response:a,expirationTime:r}}),a;o="not enough headers"===r?o:r}const d=g(a,i.data);"function"==typeof o&&(o=await o(a)),s.staleIfError&&(a.headers[n.XAxiosCacheStaleIfError]=String(o)),e.debug?.({id:a.id,msg:"Useful response configuration found",data:{cacheConfig:s,ttl:o,cacheResponse:d}}),s?.update&&await p(e.storage,a,s.update);const c={state:"cached",ttl:o,createdAt:Date.now(),data:d},u=e.waiting[a.id];return u&&(u.resolve(c.data),delete e.waiting[a.id],e.debug?.({id:a.id,msg:"Found waiting deferred(s) and resolved them"})),await e.storage.set(a.id,c),e.debug?.({id:a.id,msg:"Response cached",data:{cache:c,response:a}}),a},r=async a=>{const r=a.config;if(!r||!1===r.cache||!r.id)throw e.debug?.({msg:"Web request returned an error but cache handling is not enabled",data:{error:a,config:r}}),a;const s=await e.storage.get(r.id),i=r.cache;if("loading"!==s.state||"stale"!==s.previous)throw await t(r.id),e.debug?.({msg:"Caught an error in the request interceptor",data:{error:a,config:r}}),a;if(i?.staleIfError){const t="function"==typeof i.staleIfError?await i.staleIfError(a.response,s,a):i.staleIfError;if(e.debug?.({msg:"Found cache if stale config for rejected response",data:{error:a,config:r,staleIfError:t}}),!0===t||"number"==typeof t&&s.createdAt+t>Date.now())return e.waiting[r.id]?.resolve(s.data),delete e.waiting[r.id],await e.storage.set(r.id,{state:"stale",createdAt:Date.now(),data:s.data}),e.debug?.({msg:"staleIfError resolved this response with cached data",data:{error:a,config:r,cache:s}}),{cached:!0,config:r,id:r.id,data:s.data.data,headers:s.data.headers,status:s.data.status,statusText:s.data.statusText}}throw e.debug?.({msg:"Received an unknown error that could not be handled",data:{error:a,config:r}}),a};return{onFulfilled:a,onRejected:r,apply:()=>e.interceptors.response.use(a,r)}}const w=Symbol(),b=e=>!!e&&!!e[w];function I(e){const t=e.data.headers;return n.ETag in t||n.LastModified in t||n.XAxiosCacheEtag in t||n.XAxiosCacheStaleIfError in t||n.XAxiosCacheLastModified in t}function y(e){return e.createdAt+e.ttl<=Date.now()}function v({set:e,find:t,remove:a}){return{[w]:1,set:e,remove:a,get:async r=>{const s=await t(r);if(!s)return{state:"empty"};if("cached"!==s.state||!y(s))return s;if(I(s)){const t={state:"stale",createdAt:s.createdAt,data:s.data};return await e(r,t),t}return await a(r),{state:"empty"}}}}function S(){const e=v({find:t=>e.data[t],set:(t,a)=>{e.data[t]=a},remove:t=>{delete e.data[t]}});return e.data=Object.create(null),e}const x=(e=>{var t={};return r.d(t,e),t})({hash:()=>a.hash}),C=/^\/|\/$/g;function A(e){return t=>{if(t.id)return t.id;const a=e(t);return"string"==typeof a||"number"==typeof a?`${a}`:`${(0,x.hash)(a)}`}}const E=A((({baseURL:e="",url:t="",method:a="get",params:r,data:s})=>(e&&(e=e.replace(C,"")),t&&(t=t.replace(C,"")),a&&(a=a.toLowerCase()),{url:e+(e&&t?"/":"")+t,params:r,method:a,data:s})));function T(e,t={}){const a=e;if(a.storage=t.storage||S(),!b(a.storage))throw new Error("Use buildStorage() function");return a.generateKey=t.generateKey||E,a.waiting=t.waiting||{},a.headerInterpreter=t.headerInterpreter||o,a.requestInterceptor=t.requestInterceptor||h(a),a.responseInterceptor=t.responseInterceptor||m(a),a.debug=t.debug,a.defaults.cache={ttl:t.ttl??3e5,interpretHeader:t.interpretHeader??!1,methods:t.methods||["get"],cachePredicate:t.cachePredicate||{statusCheck:e=>e>=200&&e<400},etag:t.etag??!1,modifiedSince:t.modifiedSince??!1,staleIfError:t.staleIfError??!1,update:t.update||{}},a.requestInterceptor.apply(),a.responseInterceptor.apply(),a}function M(e,t=""){return v({find:a=>{const r=e.getItem(t+a);return r?JSON.parse(r):void 0},remove:a=>{e.removeItem(t+a)},set:(a,r)=>{const s=()=>e.setItem(t+a,JSON.stringify(r));try{return s()}catch(r){const i=Object.entries(e).filter((([a])=>a.startsWith(t)&&e.getItem(a))).map((([e,t])=>[e,JSON.parse(t)]));for(const[t,a]of i)"cached"===a.state&&y(a)&&!I(a)&&e.removeItem(t);try{return s()}catch(t){const a=i.sort((([,e],[,t])=>(e.createdAt||0)-(t.createdAt||0)));for(const[t]of a){e.removeItem(t);try{return s()}catch(e){}}}e.removeItem(t+a)}}})}console.error("You are using a development build. Make sure to use the correct build in production"),console.error("https://axios-cache-interceptor.js.org/#/pages/installing");var R=s.h4,L=s.UN,j=s.uu,q=s.Kd,N=s.ZF,k=s.nv,K=s.p,X=s.E7,D=s.NQ,O=s.xK,U=s.G6,P=s.LN,$=s.Bw,F=s.Ad,H=s.$k,J=s.v8,W=s.Jk,G=s.tI,B=s.iS;export{R as Header,L as buildKeyGenerator,j as buildMemoryStorage,q as buildStorage,N as buildWebStorage,k as canStale,K as createCacheResponse,X as createValidateStatus,D as defaultHeaderInterpreter,O as defaultKeyGenerator,U as defaultRequestInterceptor,P as defaultResponseInterceptor,$ as isExpired,F as isMethodIn,H as isStorage,J as setupCache,W as testCachePredicate,G as updateCache,B as updateStaleRequest};
//# sourceMappingURL=dev.map