{"version":3,"file":"umd/dev.js","mappings":"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","sources":["webpack://AxiosCacheInterceptor/webpack/universalModuleDefinition","webpack://AxiosCacheInterceptor/webpack/bootstrap","webpack://AxiosCacheInterceptor/webpack/runtime/define property getters","webpack://AxiosCacheInterceptor/webpack/runtime/hasOwnProperty shorthand","webpack://AxiosCacheInterceptor/webpack/runtime/make namespace object","webpack://AxiosCacheInterceptor/./node_modules/cache-parser/dist/index.modern.js","webpack://AxiosCacheInterceptor/./src/header/headers.ts","webpack://AxiosCacheInterceptor/./src/header/interpreter.ts","webpack://AxiosCacheInterceptor/./node_modules/fast-defer/dist/index.modern.js","webpack://AxiosCacheInterceptor/./src/interceptors/util.ts","webpack://AxiosCacheInterceptor/./src/interceptors/request.ts","webpack://AxiosCacheInterceptor/./src/util/cache-predicate.ts","webpack://AxiosCacheInterceptor/./src/util/update-cache.ts","webpack://AxiosCacheInterceptor/./src/interceptors/response.ts","webpack://AxiosCacheInterceptor/./src/storage/build.ts","webpack://AxiosCacheInterceptor/./src/storage/memory.ts","webpack://AxiosCacheInterceptor/./node_modules/object-code/dist/index.modern.js","webpack://AxiosCacheInterceptor/./src/util/key-generator.ts","webpack://AxiosCacheInterceptor/./src/cache/create.ts","webpack://AxiosCacheInterceptor/./src/storage/web-api.ts","webpack://AxiosCacheInterceptor/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AxiosCacheInterceptor\"] = factory();\n\telse\n\t\troot[\"AxiosCacheInterceptor\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const e=Symbol(\"cache-parser\");function t(e){return(\"string\"==typeof e||\"number\"==typeof e)&&(e=Number(e))>=0&&e<Infinity}function a(e){return!0===e||\"number\"==typeof e||\"string\"==typeof e&&\"false\"!==e}const r=Number;function s(s){const n=Object.defineProperty({},e,{enumerable:!1,value:1});if(!s||\"string\"!=typeof s)return n;const o=function(e){const t={},a=e.toLowerCase().replace(/\\s+/g,\"\").split(\",\");for(const e in a){var r;const s=a[e].split(\"=\",2);t[s[0]]=null==(r=s[1])||r}return t}(s),i=o[\"max-age\"],u=o[\"max-stale\"],l=o[\"min-fresh\"],m=o[\"s-maxage\"],p=o[\"stale-if-error\"],c=o[\"stale-while-revalidate\"];return a(o.immutable)&&(n.immutable=!0),t(i)&&(n.maxAge=r(i)),t(u)&&(n.maxStale=r(u)),t(l)&&(n.minFresh=r(l)),a(o[\"must-revalidate\"])&&(n.mustRevalidate=!0),a(o[\"must-understand\"])&&(n.mustUnderstand=!0),a(o[\"no-cache\"])&&(n.noCache=!0),a(o[\"no-store\"])&&(n.noStore=!0),a(o[\"no-transform\"])&&(n.noTransform=!0),a(o[\"only-if-cached\"])&&(n.onlyIfCached=!0),a(o.private)&&(n.private=!0),a(o[\"proxy-revalidate\"])&&(n.proxyRevalidate=!0),a(o.public)&&(n.public=!0),t(m)&&(n.sMaxAge=r(m)),t(p)&&(n.staleIfError=r(p)),t(c)&&(n.staleWhileRevalidate=r(c)),n}function n(e){if(!e||\"object\"!=typeof e)return[];const r=[];return a(e.immutable)&&r.push(\"immutable\"),t(e.maxAge)&&r.push(`max-age=${e.maxAge}`),t(e.maxStale)&&r.push(`max-stale=${e.maxStale}`),t(e.minFresh)&&r.push(`min-fresh=${e.minFresh}`),a(e.mustRevalidate)&&r.push(\"must-revalidate\"),a(e.mustUnderstand)&&r.push(\"must-understand\"),a(e.noCache)&&r.push(\"no-cache\"),a(e.noStore)&&r.push(\"no-store\"),a(e.noTransform)&&r.push(\"no-transform\"),a(e.onlyIfCached)&&r.push(\"only-if-cached\"),a(e.private)&&r.push(\"private\"),a(e.proxyRevalidate)&&r.push(\"proxy-revalidate\"),a(e.public)&&r.push(\"public\"),t(e.sMaxAge)&&r.push(`s-maxage=${e.sMaxAge}`),t(e.staleIfError)&&r.push(`stale-if-error=${e.staleIfError}`),t(e.staleWhileRevalidate)&&r.push(`stale-while-revalidate=${e.staleWhileRevalidate}`),r}function o(t){return!!t&&!!t[e]}export{o as isCacheControl,s as parse,n as tokenize};\n//# sourceMappingURL=index.modern.js.map\n","export const Header = Object.freeze({\n    /**\n     * ```txt\n     * If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\n     */\n    IfModifiedSince: 'if-modified-since',\n    /**\n     * ```txt\n     * Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified\n     */\n    LastModified: 'last-modified',\n    /**\n     * ```txt\n     * If-None-Match: \"<etag_value>\"\n     * If-None-Match: \"<etag_value>\", \"<etag_value>\", …\n     * If-None-Match: *\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\n     */\n    IfNoneMatch: 'if-none-match',\n    /**\n     * ```txt\n     * Cache-Control: max-age=604800\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n     */\n    CacheControl: 'cache-control',\n    /**\n     * ```txt\n     * ETag: W / '<etag_value>';\n     * ETag: '<etag_value>';\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\n     */\n    ETag: 'etag',\n    /**\n     * ```txt\n     * Expires: <http-date>\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\n     */\n    Expires: 'expires',\n    /**\n     * ```txt\n     * Age: <delta-seconds>\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age\n     */\n    Age: 'age',\n    /**\n     * Used internally as metadata to mark the cache item as revalidatable and enabling\n     * stale cache state Contains a string of ASCII characters that can be used as ETag for\n     * `If-Match` header Provided by user using `cache.etag` value.\n     *\n     * ```txt\n     * X-Axios-Cache-Etag: \"<etag_value>\"\n     * ```\n     */\n    XAxiosCacheEtag: 'x-axios-cache-etag',\n    /**\n     * Used internally as metadata to mark the cache item as revalidatable and enabling\n     * stale cache state may contain `'use-cache-timestamp'` if `cache.modifiedSince` is\n     * `true`, otherwise will contain a date from `cache.modifiedSince`. If a date is\n     * provided, it can be used for `If-Modified-Since` header, otherwise the cache\n     * timestamp can be used for `If-Modified-Since` header.\n     *\n     * ```txt\n     * X-Axios-Cache-Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * X-Axios-Cache-Last-Modified: use-cache-timestamp\n     * ```\n     */\n    XAxiosCacheLastModified: 'x-axios-cache-last-modified',\n    /**\n     * Used internally as metadata to mark the cache item able to be used if the server\n     * returns an error. The stale-if-error response directive indicates that the cache can\n     * reuse a stale response when any error occurs.\n     *\n     * ```txt\n     * XAxiosCacheStaleIfError: <seconds>\n     * ```\n     */\n    XAxiosCacheStaleIfError: 'x-axios-cache-stale-if-error'\n});\n","import { parse } from 'cache-parser';\nimport { Header } from './headers';\nexport const defaultHeaderInterpreter = (headers) => {\n    if (!headers)\n        return 'not enough headers';\n    const cacheControl = headers[Header.CacheControl];\n    if (cacheControl) {\n        const { noCache, noStore, mustRevalidate, maxAge, immutable } = parse(String(cacheControl));\n        // Header told that this response should not be cached.\n        if (noCache || noStore) {\n            return 'dont cache';\n        }\n        if (immutable) {\n            // 1 year is sufficient, as Infinity may cause more problems.\n            // It might not be the best way, but a year is better than none.\n            return 1000 * 60 * 60 * 24 * 365;\n        }\n        // Already out of date, for cache can be saved, but must be requested again\n        if (mustRevalidate) {\n            return 0;\n        }\n        if (maxAge) {\n            const age = headers[Header.Age];\n            if (!age) {\n                return maxAge * 1000;\n            }\n            return (maxAge - Number(age)) * 1000;\n        }\n    }\n    const expires = headers[Header.Expires];\n    if (expires) {\n        const milliseconds = Date.parse(String(expires)) - Date.now();\n        return milliseconds >= 0 ? milliseconds : 'dont cache';\n    }\n    return 'not enough headers';\n};\n","const e=Symbol();function n(){let n,t;const o=new Promise((e,o)=>{n=e,t=o});return o.resolve=n,o.reject=t,o[e]=1,o}function t(n){return!!n&&!!n[e]}export{n as deferred,t as isDeferred};\n//# sourceMappingURL=index.modern.js.map\n","import { Header } from '../header/headers';\n/**\n * Creates a new validateStatus function that will use the one already used and also\n * accept status code 304.\n */\nexport function createValidateStatus(oldValidate) {\n    return oldValidate\n        ? (status) => oldValidate(status) || status === 304\n        : (status) => (status >= 200 && status < 300) || status === 304;\n}\n/** Checks if the given method is in the methods array */\nexport function isMethodIn(requestMethod = 'get', methodList = []) {\n    requestMethod = requestMethod.toLowerCase();\n    for (const method of methodList) {\n        if (method.toLowerCase() === requestMethod) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * This function updates the cache when the request is stale. So, the next request to the\n * server will be made with proper header / settings.\n */\nexport function updateStaleRequest(cache, config) {\n    config.headers || (config.headers = {});\n    const { etag, modifiedSince } = config.cache;\n    if (etag) {\n        const etagValue = etag === true ? cache.data?.headers[Header.ETag] : etag;\n        if (etagValue) {\n            config.headers[Header.IfNoneMatch] = etagValue;\n        }\n    }\n    if (modifiedSince) {\n        config.headers[Header.IfModifiedSince] =\n            modifiedSince === true\n                ? // If last-modified is not present, use the createdAt timestamp\n                    cache.data.headers[Header.LastModified] ||\n                        new Date(cache.createdAt).toUTCString()\n                : modifiedSince.toUTCString();\n    }\n}\n/**\n * Creates the new date to the cache by the provided response. Also handles possible 304\n * Not Modified by updating response properties.\n */\nexport function createCacheResponse(response, cache) {\n    if (response.status === 304 && cache) {\n        // Set the cache information into the response object\n        response.cached = true;\n        response.data = cache.data;\n        response.status = cache.status;\n        response.statusText = cache.statusText;\n        // Update possible new headers\n        response.headers = {\n            ...cache.headers,\n            ...response.headers\n        };\n        // return the old cache\n        return cache;\n    }\n    // New Response\n    return {\n        data: response.data,\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers\n    };\n}\n","import { deferred } from 'fast-defer';\nimport { createValidateStatus, isMethodIn, updateStaleRequest } from './util';\nexport function defaultRequestInterceptor(axios) {\n    const onFulfilled = async (config) => {\n        if (config.cache === false) {\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    msg: 'Ignoring cache because config.cache is false',\n                    data: config\n                });\n            }\n            return config;\n        }\n        // merge defaults with per request configuration\n        config.cache = { ...axios.defaults.cache, ...config.cache };\n        if (!isMethodIn(config.method, config.cache.methods)) {\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    msg: `Ignored because method (${config.method}) is not in cache.methods (${config.cache.methods})`\n                });\n            }\n            return config;\n        }\n        const key = (config.id = axios.generateKey(config));\n        // Assumes that the storage handled staled responses\n        let cache = await axios.storage.get(key);\n        // Not cached, continue the request, and mark it as fetching\n        emptyOrStale: if (cache.state === 'empty' || cache.state === 'stale') {\n            /**\n             * This checks for simultaneous access to a new key. The js event loop jumps on the\n             * first await statement, so the second (asynchronous call) request may have already\n             * started executing.\n             */\n            if (axios.waiting[key]) {\n                cache = (await axios.storage.get(key));\n                if (__ACI_DEV__) {\n                    axios.debug?.({\n                        id: key,\n                        msg: 'Waiting list had an deferred for this key, waiting for it to finish'\n                    });\n                }\n                break emptyOrStale;\n            }\n            // Create a deferred to resolve other requests for the same key when it's completed\n            axios.waiting[key] = deferred();\n            /**\n             * Add a default reject handler to catch when the request is aborted without others\n             * waiting for it.\n             */\n            axios.waiting[key]?.catch(() => undefined);\n            await axios.storage.set(key, {\n                state: 'loading',\n                previous: cache.state,\n                // Eslint complains a lot :)\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any\n                data: cache.data,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any\n                createdAt: cache.createdAt\n            });\n            if (cache.state === 'stale') {\n                updateStaleRequest(cache, config);\n                if (__ACI_DEV__) {\n                    axios.debug?.({\n                        id: key,\n                        msg: 'Updated stale request'\n                    });\n                }\n            }\n            config.validateStatus = createValidateStatus(config.validateStatus);\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    id: key,\n                    msg: 'Sending request, waiting for response'\n                });\n            }\n            return config;\n        }\n        let cachedResponse;\n        if (cache.state === 'loading') {\n            const deferred = axios.waiting[key];\n            // Just in case, the deferred doesn't exists.\n            /* istanbul ignore if 'really hard to test' */\n            if (!deferred) {\n                await axios.storage.remove(key);\n                return config;\n            }\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    id: key,\n                    msg: 'Detected concurrent request, waiting for it to finish'\n                });\n            }\n            try {\n                cachedResponse = await deferred;\n            }\n            catch (err) {\n                if (__ACI_DEV__) {\n                    axios.debug?.({\n                        id: key,\n                        msg: 'Deferred rejected, requesting again',\n                        data: err\n                    });\n                }\n                // The deferred is rejected when the request that we are waiting rejected cache.\n                return config;\n            }\n        }\n        else {\n            cachedResponse = cache.data;\n        }\n        // Even though the response interceptor receives this one from here,\n        // it has been configured to ignore cached responses = true\n        config.adapter = () => Promise.resolve({\n            config,\n            data: cachedResponse.data,\n            headers: cachedResponse.headers,\n            status: cachedResponse.status,\n            statusText: cachedResponse.statusText,\n            cached: true,\n            id: key\n        });\n        if (__ACI_DEV__) {\n            axios.debug?.({\n                id: key,\n                msg: 'Returning cached response'\n            });\n        }\n        return config;\n    };\n    return {\n        onFulfilled,\n        apply: () => axios.interceptors.request.use(onFulfilled)\n    };\n}\n","/** Tests an response against a {@link CachePredicateObject}. */\nexport async function testCachePredicate(response, predicate) {\n    if (typeof predicate === 'function') {\n        return predicate(response);\n    }\n    const { statusCheck, responseMatch, containsHeaders } = predicate;\n    if ((statusCheck && !(await statusCheck(response.status))) ||\n        (responseMatch && !(await responseMatch(response)))) {\n        return false;\n    }\n    if (containsHeaders) {\n        for (const header in containsHeaders) {\n            const predicate = containsHeaders[header];\n            if (predicate &&\n                !(await predicate(\n                // Axios uses lowercase headers, but if for some reason it doesn't, we should\n                // still be able to match.\n                response.headers[header.toLowerCase()] ?? response.headers[header]))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n","/** Function to update all caches, from CacheProperties.update, with the new data. */\nexport async function updateCache(storage, data, entries) {\n    for (const cacheKey in entries) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = entries[cacheKey];\n        if (value === 'delete') {\n            await storage.remove(cacheKey);\n            continue;\n        }\n        const oldValue = await storage.get(cacheKey);\n        if (oldValue.state === 'loading') {\n            continue;\n        }\n        const newValue = await value(oldValue, data);\n        if (newValue === 'delete') {\n            await storage.remove(cacheKey);\n            continue;\n        }\n        if (newValue === 'ignore') {\n            continue;\n        }\n        await storage.set(cacheKey, newValue);\n    }\n}\n","import { Header } from '../header/headers';\nimport { testCachePredicate } from '../util/cache-predicate';\nimport { updateCache } from '../util/update-cache';\nimport { createCacheResponse } from './util';\nexport function defaultResponseInterceptor(axios) {\n    /**\n     * Rejects cache for an response response.\n     *\n     * Also update the waiting list for this key by rejecting it.\n     */\n    const rejectResponse = async (responseId) => {\n        // Update the cache to empty to prevent infinite loading state\n        await axios.storage.remove(responseId);\n        // Reject the deferred if present\n        axios.waiting[responseId]?.reject(null);\n        delete axios.waiting[responseId];\n    };\n    const onFulfilled = async (response) => {\n        var _a;\n        response.id = (_a = response.config).id ?? (_a.id = axios.generateKey(response.config));\n        response.cached ?? (response.cached = false);\n        // Response is already cached\n        if (response.cached) {\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    id: response.id,\n                    msg: 'Returned cached response'\n                });\n            }\n            return response;\n        }\n        // Skip cache: either false or weird behavior\n        // config.cache should always exists, at least from global config merge.\n        if (!response.config.cache) {\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    id: response.id,\n                    msg: 'Response with config.cache === false',\n                    data: response\n                });\n            }\n            return { ...response, cached: false };\n        }\n        // Request interceptor merges defaults with per request configuration\n        const cacheConfig = response.config.cache;\n        const cache = await axios.storage.get(response.id);\n        if (\n        // If the request interceptor had a problem\n        cache.state === 'stale' ||\n            cache.state === 'empty' ||\n            // Should not hit here because of previous response.cached check\n            cache.state === 'cached') {\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    id: response.id,\n                    msg: 'Response not cached but storage is not loading',\n                    data: { cache, response }\n                });\n            }\n            return response;\n        }\n        // Config told that this response should be cached.\n        if (\n        // For 'loading' values (post stale), this check was already run in the past.\n        !cache.data &&\n            !(await testCachePredicate(response, cacheConfig.cachePredicate))) {\n            await rejectResponse(response.id);\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    id: response.id,\n                    msg: 'Cache predicate rejected this response'\n                });\n            }\n            return response;\n        }\n        // avoid remnant headers from remote server to break implementation\n        for (const header in Header) {\n            if (!header.startsWith('XAxiosCache')) {\n                continue;\n            }\n            delete response.headers[header];\n        }\n        if (cacheConfig.etag && cacheConfig.etag !== true) {\n            response.headers[Header.XAxiosCacheEtag] = cacheConfig.etag;\n        }\n        if (cacheConfig.modifiedSince) {\n            response.headers[Header.XAxiosCacheLastModified] =\n                cacheConfig.modifiedSince === true\n                    ? 'use-cache-timestamp'\n                    : cacheConfig.modifiedSince.toUTCString();\n        }\n        let ttl = cacheConfig.ttl || -1; // always set from global config\n        if (cacheConfig?.interpretHeader) {\n            const expirationTime = axios.headerInterpreter(response.headers);\n            // Cache should not be used\n            if (expirationTime === 'dont cache') {\n                await rejectResponse(response.id);\n                if (__ACI_DEV__) {\n                    axios.debug?.({\n                        id: response.id,\n                        msg: `Cache header interpreted as 'dont cache'`,\n                        data: {\n                            cache,\n                            response,\n                            expirationTime\n                        }\n                    });\n                }\n                return response;\n            }\n            ttl = expirationTime === 'not enough headers' ? ttl : expirationTime;\n        }\n        const data = createCacheResponse(response, cache.data);\n        if (typeof ttl === 'function') {\n            ttl = await ttl(response);\n        }\n        if (cacheConfig.staleIfError) {\n            response.headers[Header.XAxiosCacheStaleIfError] = String(ttl);\n        }\n        if (__ACI_DEV__) {\n            axios.debug?.({\n                id: response.id,\n                msg: 'Useful response configuration found',\n                data: { cacheConfig, ttl, cacheResponse: data }\n            });\n        }\n        // Update other entries before updating himself\n        if (cacheConfig?.update) {\n            await updateCache(axios.storage, response, cacheConfig.update);\n        }\n        const newCache = {\n            state: 'cached',\n            ttl,\n            createdAt: Date.now(),\n            data\n        };\n        // Resolve all other requests waiting for this response\n        const waiting = axios.waiting[response.id];\n        if (waiting) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            waiting.resolve(newCache.data);\n            delete axios.waiting[response.id];\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    id: response.id,\n                    msg: 'Found waiting deferred(s) and resolved them'\n                });\n            }\n        }\n        // Define this key as cache on the storage\n        await axios.storage.set(response.id, newCache);\n        if (__ACI_DEV__) {\n            axios.debug?.({\n                id: response.id,\n                msg: 'Response cached',\n                data: { cache: newCache, response }\n            });\n        }\n        // Return the response with cached as false, because it was not cached at all\n        return response;\n    };\n    const onRejected = async (error) => {\n        const config = error['config'];\n        if (!config || config.cache === false || !config.id) {\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    msg: 'Web request returned an error but cache handling is not enabled',\n                    data: { error, config }\n                });\n            }\n            throw error;\n        }\n        const cache = await axios.storage.get(config.id);\n        const cacheConfig = config.cache;\n        if (\n        // This will only not be loading if the interceptor broke\n        cache.state !== 'loading' ||\n            cache.previous !== 'stale') {\n            await rejectResponse(config.id);\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    msg: 'Caught an error in the request interceptor',\n                    data: { error, config }\n                });\n            }\n            throw error;\n        }\n        if (cacheConfig?.staleIfError) {\n            const staleIfError = typeof cacheConfig.staleIfError === 'function'\n                ? await cacheConfig.staleIfError(error.response, cache, error)\n                : cacheConfig.staleIfError;\n            if (__ACI_DEV__) {\n                axios.debug?.({\n                    msg: 'Found cache if stale config for rejected response',\n                    data: { error, config, staleIfError }\n                });\n            }\n            if (staleIfError === true ||\n                // staleIfError is the number of seconds that stale is allowed to be used\n                (typeof staleIfError === 'number' && cache.createdAt + staleIfError > Date.now())) {\n                // Resolve all other requests waiting for this response\n                axios.waiting[config.id]?.resolve(cache.data);\n                delete axios.waiting[config.id];\n                // re-mark the cache as stale\n                await axios.storage.set(config.id, {\n                    state: 'stale',\n                    createdAt: Date.now(),\n                    data: cache.data\n                });\n                if (__ACI_DEV__) {\n                    axios.debug?.({\n                        msg: 'staleIfError resolved this response with cached data',\n                        data: { error, config, cache }\n                    });\n                }\n                return {\n                    cached: true,\n                    config,\n                    id: config.id,\n                    data: cache.data.data,\n                    headers: cache.data.headers,\n                    status: cache.data.status,\n                    statusText: cache.data.statusText\n                };\n            }\n        }\n        if (__ACI_DEV__) {\n            axios.debug?.({\n                msg: 'Received an unknown error that could not be handled',\n                data: { error, config }\n            });\n        }\n        throw error;\n    };\n    return {\n        onFulfilled,\n        onRejected,\n        apply: () => axios.interceptors.response.use(onFulfilled, onRejected)\n    };\n}\n","import { Header } from '../header/headers';\nconst storage = Symbol();\n/** Returns true if the provided object was created from {@link buildStorage} function. */\nexport const isStorage = (obj) => !!obj && !!obj[storage];\n/** Returns true if this storage is expired, but it has sufficient properties to stale. */\nexport function canStale(value) {\n    const headers = value.data.headers;\n    return (Header.ETag in headers ||\n        Header.LastModified in headers ||\n        Header.XAxiosCacheEtag in headers ||\n        Header.XAxiosCacheStaleIfError in headers ||\n        Header.XAxiosCacheLastModified in headers);\n}\n/** Checks if the provided cache is expired. You should also check if the cache {@link canStale} */\nexport function isExpired(value) {\n    return value.createdAt + value.ttl <= Date.now();\n}\n/**\n * Builds a custom storage.\n *\n * **Note**: You can only create an custom storage with this function.\n *\n * @example\n *\n * ```js\n * const myStorage = buildStorage({\n *   find: () => {...},\n *   set: () => {...},\n *   remove: () => {...}\n * });\n *\n * const axios = setupCache(axios, { storage: myStorage });\n * ```\n */\nexport function buildStorage({ set, find, remove }) {\n    return {\n        //@ts-expect-error - we don't want to expose this\n        [storage]: 1,\n        set,\n        remove,\n        get: async (key) => {\n            const value = await find(key);\n            if (!value) {\n                return { state: 'empty' };\n            }\n            if (\n            // Not cached or fresh value\n            value.state !== 'cached' ||\n                !isExpired(value)) {\n                return value;\n            }\n            if (canStale(value)) {\n                const stale = {\n                    state: 'stale',\n                    createdAt: value.createdAt,\n                    data: value.data\n                };\n                await set(key, stale);\n                return stale;\n            }\n            await remove(key);\n            return { state: 'empty' };\n        }\n    };\n}\n","import { buildStorage } from './build';\n/**\n * Creates a simple in-memory storage. This means that if you need to persist data between\n * page or server reloads, this will not help.\n *\n * This is the storage used by default.\n *\n * If you need to modify it's data, you can do by the `data` property.\n *\n * @example\n *\n * ```js\n * const memoryStorage = buildMemoryStorage();\n *\n * setupCache(axios, { storage: memoryStorage });\n *\n * // Simple example to force delete the request cache\n *\n * const { id } = axios.get('url');\n *\n * delete memoryStorage.data[id];\n * ```\n */\nexport function buildMemoryStorage() {\n    const storage = buildStorage({\n        find: (key) => storage.data[key],\n        set: (key, value) => {\n            storage.data[key] = value;\n        },\n        remove: (key) => {\n            delete storage.data[key];\n        }\n    });\n    storage.data = Object.create(null);\n    return storage;\n}\n","function t(n){const r=typeof n;if(n&&\"object\"==r&&!(n instanceof Date||n instanceof RegExp)){const r=Array.isArray(n)?[]:{};for(const o in n)r[o]=t(n[o]);return`${n.constructor}${JSON.stringify(r,Object.keys(n).sort())}`}return`${r}${String(n)}`}function n(n){n=t(n);let r=5381,o=0;for(;o<n.length;)r=33*r^n.charCodeAt(o++);return r}export{n as hash,t as serialize};\n//# sourceMappingURL=index.modern.js.map\n","import { hash } from 'object-code';\n// Remove first and last '/' char, if present\nconst SLASHES_REGEX = /^\\/|\\/$/g;\n/**\n * Builds an generator that receives a {@link CacheRequestConfig} and returns a value\n * hashed by {@link hash}.\n *\n * The value is hashed into a signed integer when the returned value from the provided\n * generator is not a `string` or a `number`.\n *\n * You can return any type of data structure.\n *\n * @example\n *\n * ```js\n * // This generator will return a hash code.\n * // The code will only be the same if url, method and data are the same.\n * const generator = buildKeyGenerator(({ url, method, data }) => ({\n *   url,\n *   method,\n *   data\n * }));\n * ```\n */\nexport function buildKeyGenerator(generator) {\n    return (request) => {\n        if (request.id) {\n            return request.id;\n        }\n        const key = generator(request);\n        if (typeof key === 'string' || typeof key === 'number') {\n            return `${key}`;\n        }\n        return `${hash(key)}`;\n    };\n}\nexport const defaultKeyGenerator = buildKeyGenerator(({ baseURL = '', url = '', method = 'get', params, data }) => {\n    // Remove trailing slashes to avoid generating different keys for the \"same\" final url.\n    baseURL && (baseURL = baseURL.replace(SLASHES_REGEX, ''));\n    url && (url = url.replace(SLASHES_REGEX, ''));\n    // lowercase method\n    method && (method = method.toLowerCase());\n    return {\n        url: baseURL + (baseURL && url ? '/' : '') + url,\n        params: params,\n        method,\n        data\n    };\n});\n","import { defaultHeaderInterpreter } from '../header/interpreter';\nimport { defaultRequestInterceptor } from '../interceptors/request';\nimport { defaultResponseInterceptor } from '../interceptors/response';\nimport { isStorage } from '../storage/build';\nimport { buildMemoryStorage } from '../storage/memory';\nimport { defaultKeyGenerator } from '../util/key-generator';\n/**\n * Apply the caching interceptors for a already created axios instance.\n *\n * @example\n *\n * ```ts\n * import Axios from 'axios';\n * import { setupCache, AxiosCacheInstance } from 'axios-cache-interceptor';\n *\n * // instance will have our custom typings from the return of this function\n * const instance = setupCache(\n *   Axios.create({\n *     // Axios options\n *   }),\n *   {\n *     // Axios-cache-interceptor options\n *   }\n * );\n *\n * // OR\n *\n * const instance = axios.create({\n *   // Axios options\n * }) as AxiosCacheInstance;\n *\n * // As this functions returns the same axios instance but only with\n * // different typings, you can ignore the function return.\n * setupCache(instance, {\n *   // Axios-cache-interceptor options\n * });\n * ```\n *\n * @param axios The already created axios instance\n * @param config The config for the caching interceptors\n * @returns The same instance with extended typescript types.\n */\nexport function setupCache(axios, options = {}) {\n    const axiosCache = axios;\n    axiosCache.storage = options.storage || buildMemoryStorage();\n    if (!isStorage(axiosCache.storage)) {\n        throw new Error('Use buildStorage() function');\n    }\n    axiosCache.generateKey = options.generateKey || defaultKeyGenerator;\n    axiosCache.waiting = options.waiting || {};\n    axiosCache.headerInterpreter = options.headerInterpreter || defaultHeaderInterpreter;\n    axiosCache.requestInterceptor =\n        options.requestInterceptor || defaultRequestInterceptor(axiosCache);\n    axiosCache.responseInterceptor =\n        options.responseInterceptor || defaultResponseInterceptor(axiosCache);\n    axiosCache.debug = options.debug;\n    // CacheRequestConfig values\n    axiosCache.defaults.cache = {\n        ttl: options.ttl ?? 1000 * 60 * 5,\n        interpretHeader: options.interpretHeader ?? false,\n        methods: options.methods || ['get'],\n        cachePredicate: options.cachePredicate || {\n            statusCheck: (status) => status >= 200 && status < 400\n        },\n        etag: options.etag ?? false,\n        modifiedSince: options.modifiedSince ?? false,\n        staleIfError: options.staleIfError ?? false,\n        update: options.update || {}\n    };\n    // Apply interceptors\n    axiosCache.requestInterceptor.apply();\n    axiosCache.responseInterceptor.apply();\n    return axiosCache;\n}\n","import { buildStorage, canStale, isExpired } from './build';\n/**\n * Creates a simple storage. You can persist his data by using `sessionStorage` or\n * `localStorage` with it.\n *\n * **ImplNote**: Without polyfill, this storage only works on browser environments.\n *\n * @example\n *\n * ```js\n * const fromLocalStorage = buildWebStorage(localStorage);\n * const fromSessionStorage = buildWebStorage(sessionStorage);\n *\n * const myStorage = new Storage();\n * const fromMyStorage = buildWebStorage(myStorage);\n * ```\n *\n * @param storage The type of web storage to use. localStorage or sessionStorage.\n * @param prefix The prefix to index the storage. Useful to prevent collision between\n *   multiple places using the same storage.\n */\nexport function buildWebStorage(storage, prefix = '') {\n    return buildStorage({\n        find: (key) => {\n            const json = storage.getItem(prefix + key);\n            return json ? JSON.parse(json) : undefined;\n        },\n        remove: (key) => {\n            storage.removeItem(prefix + key);\n        },\n        set: (key, value) => {\n            const save = () => storage.setItem(prefix + key, JSON.stringify(value));\n            try {\n                return save();\n            }\n            catch (error) {\n                const allValues = Object.entries(storage)\n                    .filter(([key]) => key.startsWith(prefix) && storage.getItem(key))\n                    .map(([key, val]) => [key, JSON.parse(val)]);\n                // Remove all expired values\n                for (const [prefixedKey, value] of allValues) {\n                    if (value.state === 'cached' && isExpired(value) && !canStale(value)) {\n                        storage.removeItem(prefixedKey);\n                    }\n                }\n                // Try save again after removing expired values\n                try {\n                    return save();\n                }\n                catch (_) {\n                    // Storage still full, try removing the oldest value until it can be saved\n                    // Descending sort by createdAt\n                    const sortedItems = allValues.sort(([, valueA], [, valueB]) => (valueA.createdAt || 0) - (valueB.createdAt || 0));\n                    for (const [prefixedKey] of sortedItems) {\n                        storage.removeItem(prefixedKey);\n                        try {\n                            return save();\n                        }\n                        catch (_) {\n                            // This key didn't free all the required space\n                        }\n                    }\n                }\n                // Clear the cache for the specified key\n                storage.removeItem(prefix + key);\n            }\n        }\n    });\n}\n","export * from './cache/axios';\nexport * from './cache/cache';\nexport * from './cache/create';\nexport * from './header/headers';\nexport * from './header/interpreter';\nexport * from './header/types';\nexport * from './interceptors/build';\nexport * from './interceptors/request';\nexport * from './interceptors/response';\nexport * from './interceptors/util';\nexport * from './storage/build';\nexport * from './storage/memory';\nexport * from './storage/types';\nexport * from './storage/web-api';\nexport * from './util/cache-predicate';\nexport * from './util/key-generator';\nexport * from './util/types';\nexport * from './util/update-cache';\nif (__ACI_DEV__) {\n    console.error('You are using a development build. Make sure to use the correct build in production');\n    console.error('https://axios-cache-interceptor.js.org/#/pages/installing');\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","e","t","Number","Infinity","a","r","Header","freeze","IfModifiedSince","LastModified","IfNoneMatch","CacheControl","ETag","Expires","Age","XAxiosCacheEtag","XAxiosCacheLastModified","XAxiosCacheStaleIfError","defaultHeaderInterpreter","headers","cacheControl","noCache","noStore","mustRevalidate","maxAge","immutable","s","n","toLowerCase","replace","split","i","u","l","m","p","c","maxStale","minFresh","mustUnderstand","noTransform","onlyIfCached","private","proxyRevalidate","public","sMaxAge","staleIfError","staleWhileRevalidate","String","age","expires","milliseconds","Date","parse","now","createValidateStatus","oldValidate","status","isMethodIn","requestMethod","methodList","method","updateStaleRequest","cache","config","etag","modifiedSince","etagValue","data","createdAt","toUTCString","createCacheResponse","response","cached","statusText","defaultRequestInterceptor","axios","onFulfilled","async","debug","msg","defaults","methods","id","generateKey","cachedResponse","storage","emptyOrStale","state","waiting","Promise","resolve","reject","catch","set","previous","validateStatus","deferred","remove","err","adapter","apply","interceptors","request","use","testCachePredicate","predicate","statusCheck","responseMatch","containsHeaders","header","updateCache","entries","cacheKey","oldValue","newValue","defaultResponseInterceptor","rejectResponse","responseId","_a","cacheConfig","cachePredicate","startsWith","ttl","interpretHeader","expirationTime","headerInterpreter","cacheResponse","update","newCache","onRejected","error","isStorage","canStale","isExpired","buildStorage","find","stale","buildMemoryStorage","create","RegExp","Array","isArray","constructor","JSON","stringify","keys","sort","length","charCodeAt","SLASHES_REGEX","buildKeyGenerator","generator","defaultKeyGenerator","baseURL","url","params","setupCache","options","axiosCache","Error","requestInterceptor","responseInterceptor","buildWebStorage","prefix","json","getItem","undefined","removeItem","save","setItem","allValues","filter","map","val","prefixedKey","_","sortedItems","valueA","valueB","console"],"sourceRoot":""}