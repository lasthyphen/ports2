{"version":3,"sources":["../src/reach-machine.ts"],"sourcesContent":["import * as React from \"react\";\nimport {\n\tassign,\n\tcreateMachine,\n\tinterpret,\n\tInterpreterStatus,\n} from \"@xstate/fsm\";\nimport type {\n\tEventObject as MachineEvent,\n\tStateMachine,\n\tTypestate,\n} from \"@xstate/fsm\";\nimport { isString, useConstant } from \"@reach/utils\";\nimport type { DistributiveOmit } from \"@reach/utils\";\n\ndeclare const __DEV__: boolean;\n\nconst getServiceState = <\n\tTContext extends object,\n\tTEvent extends MachineEvent = MachineEvent,\n\tTState extends Typestate<TContext> = any\n>(\n\tservice: StateMachine.Service<TContext, TEvent, TState>\n): StateMachine.State<TContext, TEvent, TState> => {\n\tlet currentValue: StateMachine.State<TContext, TEvent, TState>;\n\tservice\n\t\t.subscribe((state) => {\n\t\t\tcurrentValue = state;\n\t\t})\n\t\t.unsubscribe();\n\treturn currentValue!;\n};\n\n/**\n * This `useMachine` works very similiarly to what you get from `@xstate/react`\n * with some additions.\n *  - A second argument `refs` is passed to send all of our refs into our\n *    machine's contextual data object.\n *  - We wrap the `send` function so that refs are updated included in all of\n *    our events so we can use their current value (generally DOM nodes)\n *    anywhere in our actions.\n *  - We initialize the machine inside the component rather than throwing an\n *    error if an outside initializer creates a value that doesn't match. This\n *    is useful as some components may need a different initial state or some\n *    initial data based on props. We should *generally* just update the state\n *    with an event via useEffect and depend on a static initial value, but this\n *    is difficult if that initial value matters for SSR or to prevent some\n *    layout jank before the first paint. I don't think there's a problem with\n *    this approach, but we'll see what happens.\n *\n * @param initialMachine\n * @param refs\n */\nexport function useMachine<\n\tTC extends object,\n\tTE extends MachineEventWithRefs = MachineEventWithRefs,\n\tTS extends Typestate<TC> = any\n>(\n\tinitialMachine: StateMachine.Machine<TC, TE, TS>,\n\trefs: MachineToReactRefMap<TE>,\n\tDEBUG?: boolean\n): [\n\tOmit<StateMachine.State<TC, TE, TS>, \"actions\">,\n\tStateMachine.Service<TC, DistributiveOmit<TE, \"refs\">>[\"send\"],\n\tStateMachine.Service<TC, TE>\n] {\n\t// State machine should not change between renders, so let's store it in a\n\t// ref. This should also help if we need to use a creator function to inject\n\t// dynamic initial state values based on props.\n\tlet machineRef = React.useRef(initialMachine);\n\tlet service = useConstant(() => interpret(machineRef.current).start());\n\tlet lastEventType = React.useRef<TE[\"type\"] | null>(null);\n\n\tlet [state, setState] = React.useState(() => getServiceState(service));\n\n\t// This function reference will change on every render if we just pass on\n\t// current.matches, but it shouldn't change unless the current value is\n\t// updated. This was causing some lagginess when profiling in Listbox but\n\t// is probably an issue everywhere since the parent components that handle\n\t// state logic at the top might re-create context on each render as a\n\t// result of this change.\n\n\t// Add refs to every event so we can use them to perform actions.\n\tlet send = React.useCallback(\n\t\t(rawEvent: TE[\"type\"] | DistributiveOmit<TE, \"refs\">) => {\n\t\t\tlet event = isString(rawEvent) ? { type: rawEvent } : rawEvent;\n\t\t\tlet refValues = unwrapRefs(refs);\n\t\t\tservice.send({\n\t\t\t\t...event,\n\t\t\t\tlastEventType: lastEventType.current,\n\t\t\t\trefs: refValues,\n\t\t\t} as TE);\n\t\t\tlastEventType.current = event.type;\n\n\t\t\tif (__DEV__) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tconsole.group(\"Event Sent\");\n\t\t\t\t\tconsole.log(\"Event:\", event);\n\t\t\t\t\tconsole.groupEnd();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// We can disable the lint warning here. Refs will always be refs\n\t\t// (TypeScript enforced!) and should not trigger a re-render. The state\n\t\t// machine service persist for the life of the component.\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t[DEBUG]\n\t);\n\n\tReact.useEffect(() => {\n\t\tservice.subscribe(function setStateIfChanged(newState) {\n\t\t\tif (newState.changed) {\n\t\t\t\tsetState(newState);\n\t\t\t}\n\t\t});\n\t\treturn () => {\n\t\t\tservice.stop();\n\t\t};\n\t}, [service]);\n\n\tReact.useEffect(() => {\n\t\tif (__DEV__) {\n\t\t\tif (DEBUG && state.changed) {\n\t\t\t\tconsole.group(\"State Updated\");\n\t\t\t\tconsole.log(\"State:\", state);\n\t\t\t\tconsole.groupEnd();\n\t\t\t}\n\t\t}\n\t}, [DEBUG, state]);\n\n\t// We are going to pass along our state without the actions to avoid excess\n\t// renders when the reference changes. We haven't really needed them at this\n\t// point, but if we do we can maybe reconsider this approach.\n\tconst memoizedState = React.useMemo(\n\t\t() => ({\n\t\t\t...state,\n\t\t\tmatches: (value: any) => value === state.value,\n\t\t}),\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t[state.changed, state.context, state.value]\n\t);\n\n\treturn [memoizedState, send, service];\n}\n\n/**\n * Converts an object with React refs into an object with the same keys and\n * the current value of those refs.\n *\n * @param refs\n */\nexport function unwrapRefs<\n\tTE extends MachineEventWithRefs = MachineEventWithRefs\n>(refs: MachineToReactRefMap<TE>): TE[\"refs\"] {\n\treturn Object.entries(refs).reduce((value, [name, ref]) => {\n\t\t(value as any)[name] = ref.current;\n\t\treturn value;\n\t}, {} as TE[\"refs\"]);\n}\n\n/**\n * Most of the time you want to create a static state machine outside of your\n * component, but in some cases we may need data from props in the first render\n * cycle. We can create our machine in each component IF we only create it once\n * and guarantee that it never changes between renders.\n *\n * This hook can take a machine definition created by a function inline to use\n * values defined in the component, and we never change the machine for the\n * life of the component.\n *\n * @param machineDefinition\n * @param options\n */\nexport function useCreateMachine<\n\tTC extends object,\n\tTE extends MachineEventWithRefs = MachineEventWithRefs,\n\tTS extends Typestate<TC> = any\n>(\n\tmachineDefinition: StateMachine.Config<TC, TE, TS>,\n\toptions?: {\n\t\tactions?: StateMachine.ActionMap<TC, TE>;\n\t}\n): StateMachine.Machine<TC, TE, TS> {\n\treturn useConstant(() => createMachine(machineDefinition, options));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\n/**\n * Events use in our `useMachine` always have a refs object and will inherit\n * this interface.\n */\nexport interface MachineEventWithRefs extends MachineEvent {\n\trefs: {\n\t\t[key: string]: any;\n\t};\n\tlastEventType?: MachineEventWithRefs[\"type\"];\n}\n\nexport type MachineToReactRefMap<TE extends MachineEventWithRefs> = {\n\t[K in keyof TE[\"refs\"]]: React.RefObject<TE[\"refs\"][K]>;\n};\n\nexport type MachineState<\n\tTC extends object,\n\tTE extends MachineEventWithRefs = MachineEventWithRefs,\n\tTS extends Typestate<TC> = any\n> = StateMachine.State<TC, TE, TS>;\n\nexport type MachineSend<\n\tTC extends object,\n\tTE extends MachineEventWithRefs = MachineEventWithRefs\n> = StateMachine.Service<TC, DistributiveOmit<TE, \"refs\">>[\"send\"];\n\nexport type MachineService<\n\tTC extends object,\n\tTE extends MachineEventWithRefs = MachineEventWithRefs\n> = StateMachine.Service<TC, TE>;\n\n// Export types and functions from xstate/fsm\nexport type { MachineEvent, StateMachine };\nexport { InterpreterStatus, createMachine, assign, interpret };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAuB;AACvB,iBAKO;AAMP,mBAAsC;AAKtC,IAAM,kBAAkB,CAKvB,YACkD;AAClD,MAAI;AACJ,UACE,UAAU,CAAC,UAAU;AACrB,mBAAe;AAAA,EAChB,CAAC,EACA,YAAY;AACd,SAAO;AACR;AAsBO,oBAKN,gBACA,MACA,OAKC;AAID,MAAI,aAAa,AAAM,aAAO,cAAc;AAC5C,MAAI,UAAU,8BAAY,MAAM,0BAAU,WAAW,OAAO,EAAE,MAAM,CAAC;AACrE,MAAI,gBAAgB,AAAM,aAA0B,IAAI;AAExD,MAAI,CAAC,OAAO,YAAY,AAAM,eAAS,MAAM,gBAAgB,OAAO,CAAC;AAUrE,MAAI,OAAO,AAAM,kBAChB,CAAC,aAAwD;AACxD,QAAI,QAAQ,2BAAS,QAAQ,IAAI,EAAE,MAAM,SAAS,IAAI;AACtD,QAAI,YAAY,WAAW,IAAI;AAC/B,YAAQ,KAAK,iCACT,QADS;AAAA,MAEZ,eAAe,cAAc;AAAA,MAC7B,MAAM;AAAA,IACP,EAAO;AACP,kBAAc,UAAU,MAAM;AAE9B,QAAI,MAAS;AACZ,UAAI,OAAO;AACV,gBAAQ,MAAM,YAAY;AAC1B,gBAAQ,IAAI,UAAU,KAAK;AAC3B,gBAAQ,SAAS;AAAA,MAClB;AAAA,IACD;AAAA,EACD,GAKA,CAAC,KAAK,CACP;AAEA,EAAM,gBAAU,MAAM;AACrB,YAAQ,UAAU,2BAA2B,UAAU;AACtD,UAAI,SAAS,SAAS;AACrB,iBAAS,QAAQ;AAAA,MAClB;AAAA,IACD,CAAC;AACD,WAAO,MAAM;AACZ,cAAQ,KAAK;AAAA,IACd;AAAA,EACD,GAAG,CAAC,OAAO,CAAC;AAEZ,EAAM,gBAAU,MAAM;AACrB,QAAI,MAAS;AACZ,UAAI,SAAS,MAAM,SAAS;AAC3B,gBAAQ,MAAM,eAAe;AAC7B,gBAAQ,IAAI,UAAU,KAAK;AAC3B,gBAAQ,SAAS;AAAA,MAClB;AAAA,IACD;AAAA,EACD,GAAG,CAAC,OAAO,KAAK,CAAC;AAKjB,QAAM,gBAAgB,AAAM,cAC3B,MAAO,iCACH,QADG;AAAA,IAEN,SAAS,CAAC,UAAe,UAAU,MAAM;AAAA,EAC1C,IAEA,CAAC,MAAM,SAAS,MAAM,SAAS,MAAM,KAAK,CAC3C;AAEA,SAAO,CAAC,eAAe,MAAM,OAAO;AACrC;AAQO,oBAEL,MAA4C;AAC7C,SAAO,OAAO,QAAQ,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,MAAM,SAAS;AAC1D,IAAC,MAAc,QAAQ,IAAI;AAC3B,WAAO;AAAA,EACR,GAAG,CAAC,CAAe;AACpB;AAeO,0BAKN,mBACA,SAGmC;AACnC,SAAO,8BAAY,MAAM,8BAAc,mBAAmB,OAAO,CAAC;AACnE;","names":[]}