import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../common";
export interface EndInterface extends utils.Interface {
    functions: {
        "Art(bytes32)": FunctionFragment;
        "bag(address)": FunctionFragment;
        "cage()": FunctionFragment;
        "cage(bytes32)": FunctionFragment;
        "cash(bytes32,uint256)": FunctionFragment;
        "cat()": FunctionFragment;
        "cure()": FunctionFragment;
        "debt()": FunctionFragment;
        "deny(address)": FunctionFragment;
        "dog()": FunctionFragment;
        "file(bytes32,uint256)": FunctionFragment;
        "file(bytes32,address)": FunctionFragment;
        "fix(bytes32)": FunctionFragment;
        "flow(bytes32)": FunctionFragment;
        "free(bytes32)": FunctionFragment;
        "gap(bytes32)": FunctionFragment;
        "live()": FunctionFragment;
        "out(bytes32,address)": FunctionFragment;
        "pack(uint256)": FunctionFragment;
        "pot()": FunctionFragment;
        "rely(address)": FunctionFragment;
        "skim(bytes32,address)": FunctionFragment;
        "skip(bytes32,uint256)": FunctionFragment;
        "snip(bytes32,uint256)": FunctionFragment;
        "spot()": FunctionFragment;
        "tag(bytes32)": FunctionFragment;
        "thaw()": FunctionFragment;
        "vat()": FunctionFragment;
        "vow()": FunctionFragment;
        "wait()": FunctionFragment;
        "wards(address)": FunctionFragment;
        "when()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "Art" | "bag" | "cage()" | "cage(bytes32)" | "cash" | "cat" | "cure" | "debt" | "deny" | "dog" | "file(bytes32,uint256)" | "file(bytes32,address)" | "fix" | "flow" | "free" | "gap" | "live" | "out" | "pack" | "pot" | "rely" | "skim" | "skip" | "snip" | "spot" | "tag" | "thaw" | "vat" | "vow" | "wait" | "wards" | "when"): FunctionFragment;
    encodeFunctionData(functionFragment: "Art", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "bag", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "cage()", values?: undefined): string;
    encodeFunctionData(functionFragment: "cage(bytes32)", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "cash", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "cat", values?: undefined): string;
    encodeFunctionData(functionFragment: "cure", values?: undefined): string;
    encodeFunctionData(functionFragment: "debt", values?: undefined): string;
    encodeFunctionData(functionFragment: "deny", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "dog", values?: undefined): string;
    encodeFunctionData(functionFragment: "file(bytes32,uint256)", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "file(bytes32,address)", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "fix", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "flow", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "free", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "gap", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "live", values?: undefined): string;
    encodeFunctionData(functionFragment: "out", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "pack", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "pot", values?: undefined): string;
    encodeFunctionData(functionFragment: "rely", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "skim", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "skip", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "snip", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "spot", values?: undefined): string;
    encodeFunctionData(functionFragment: "tag", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "thaw", values?: undefined): string;
    encodeFunctionData(functionFragment: "vat", values?: undefined): string;
    encodeFunctionData(functionFragment: "vow", values?: undefined): string;
    encodeFunctionData(functionFragment: "wait", values?: undefined): string;
    encodeFunctionData(functionFragment: "wards", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "when", values?: undefined): string;
    decodeFunctionResult(functionFragment: "Art", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "bag", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cage()", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cage(bytes32)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cat", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cure", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "debt", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deny", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dog", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "file(bytes32,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "file(bytes32,address)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fix", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "flow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "free", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "gap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "live", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "out", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pack", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pot", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rely", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "skim", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "skip", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "snip", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "spot", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tag", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "thaw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "vat", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "vow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wait", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wards", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "when", data: BytesLike): Result;
    events: {
        "Cage()": EventFragment;
        "Cage(bytes32)": EventFragment;
        "Cash(bytes32,address,uint256)": EventFragment;
        "Deny(address)": EventFragment;
        "File(bytes32,uint256)": EventFragment;
        "File(bytes32,address)": EventFragment;
        "Flow(bytes32)": EventFragment;
        "Free(bytes32,address,uint256)": EventFragment;
        "Pack(address,uint256)": EventFragment;
        "Rely(address)": EventFragment;
        "Skim(bytes32,address,uint256,uint256)": EventFragment;
        "Skip(bytes32,uint256,address,uint256,uint256,uint256)": EventFragment;
        "Snip(bytes32,uint256,address,uint256,uint256,uint256)": EventFragment;
        "Thaw()": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Cage()"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Cage(bytes32)"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Cash"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Deny"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "File(bytes32,uint256)"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "File(bytes32,address)"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Flow"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Free"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Pack"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Rely"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Skim"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Skip"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Snip"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Thaw"): EventFragment;
}
export interface Cage__EventObject {
}
export declare type Cage__Event = TypedEvent<[], Cage__EventObject>;
export declare type Cage__EventFilter = TypedEventFilter<Cage__Event>;
export interface Cage_bytes32_EventObject {
    ilk: string;
}
export declare type Cage_bytes32_Event = TypedEvent<[string], Cage_bytes32_EventObject>;
export declare type Cage_bytes32_EventFilter = TypedEventFilter<Cage_bytes32_Event>;
export interface CashEventObject {
    ilk: string;
    usr: string;
    wad: BigNumber;
}
export declare type CashEvent = TypedEvent<[
    string,
    string,
    BigNumber
], CashEventObject>;
export declare type CashEventFilter = TypedEventFilter<CashEvent>;
export interface DenyEventObject {
    usr: string;
}
export declare type DenyEvent = TypedEvent<[string], DenyEventObject>;
export declare type DenyEventFilter = TypedEventFilter<DenyEvent>;
export interface File_bytes32_uint256_EventObject {
    what: string;
    data: BigNumber;
}
export declare type File_bytes32_uint256_Event = TypedEvent<[
    string,
    BigNumber
], File_bytes32_uint256_EventObject>;
export declare type File_bytes32_uint256_EventFilter = TypedEventFilter<File_bytes32_uint256_Event>;
export interface File_bytes32_address_EventObject {
    what: string;
    data: string;
}
export declare type File_bytes32_address_Event = TypedEvent<[
    string,
    string
], File_bytes32_address_EventObject>;
export declare type File_bytes32_address_EventFilter = TypedEventFilter<File_bytes32_address_Event>;
export interface FlowEventObject {
    ilk: string;
}
export declare type FlowEvent = TypedEvent<[string], FlowEventObject>;
export declare type FlowEventFilter = TypedEventFilter<FlowEvent>;
export interface FreeEventObject {
    ilk: string;
    usr: string;
    ink: BigNumber;
}
export declare type FreeEvent = TypedEvent<[
    string,
    string,
    BigNumber
], FreeEventObject>;
export declare type FreeEventFilter = TypedEventFilter<FreeEvent>;
export interface PackEventObject {
    usr: string;
    wad: BigNumber;
}
export declare type PackEvent = TypedEvent<[string, BigNumber], PackEventObject>;
export declare type PackEventFilter = TypedEventFilter<PackEvent>;
export interface RelyEventObject {
    usr: string;
}
export declare type RelyEvent = TypedEvent<[string], RelyEventObject>;
export declare type RelyEventFilter = TypedEventFilter<RelyEvent>;
export interface SkimEventObject {
    ilk: string;
    urn: string;
    wad: BigNumber;
    art: BigNumber;
}
export declare type SkimEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], SkimEventObject>;
export declare type SkimEventFilter = TypedEventFilter<SkimEvent>;
export interface SkipEventObject {
    ilk: string;
    id: BigNumber;
    usr: string;
    tab: BigNumber;
    lot: BigNumber;
    art: BigNumber;
}
export declare type SkipEvent = TypedEvent<[
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber
], SkipEventObject>;
export declare type SkipEventFilter = TypedEventFilter<SkipEvent>;
export interface SnipEventObject {
    ilk: string;
    id: BigNumber;
    usr: string;
    tab: BigNumber;
    lot: BigNumber;
    art: BigNumber;
}
export declare type SnipEvent = TypedEvent<[
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber
], SnipEventObject>;
export declare type SnipEventFilter = TypedEventFilter<SnipEvent>;
export interface ThawEventObject {
}
export declare type ThawEvent = TypedEvent<[], ThawEventObject>;
export declare type ThawEventFilter = TypedEventFilter<ThawEvent>;
export interface End extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: EndInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        Art(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;
        bag(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        "cage()"(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "cage(bytes32)"(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        cash(ilk: PromiseOrValue<BytesLike>, wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        cat(overrides?: CallOverrides): Promise<[string]>;
        cure(overrides?: CallOverrides): Promise<[string]>;
        debt(overrides?: CallOverrides): Promise<[BigNumber]>;
        deny(usr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        dog(overrides?: CallOverrides): Promise<[string]>;
        "file(bytes32,uint256)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "file(bytes32,address)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        fix(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;
        flow(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        free(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        gap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;
        live(overrides?: CallOverrides): Promise<[BigNumber]>;
        out(arg0: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        pack(wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pot(overrides?: CallOverrides): Promise<[string]>;
        rely(usr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        skim(ilk: PromiseOrValue<BytesLike>, urn: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        skip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        snip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        spot(overrides?: CallOverrides): Promise<[string]>;
        tag(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;
        thaw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        vat(overrides?: CallOverrides): Promise<[string]>;
        vow(overrides?: CallOverrides): Promise<[string]>;
        wait(overrides?: CallOverrides): Promise<[BigNumber]>;
        wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        when(overrides?: CallOverrides): Promise<[BigNumber]>;
    };
    Art(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    bag(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    "cage()"(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "cage(bytes32)"(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    cash(ilk: PromiseOrValue<BytesLike>, wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    cat(overrides?: CallOverrides): Promise<string>;
    cure(overrides?: CallOverrides): Promise<string>;
    debt(overrides?: CallOverrides): Promise<BigNumber>;
    deny(usr: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    dog(overrides?: CallOverrides): Promise<string>;
    "file(bytes32,uint256)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "file(bytes32,address)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    fix(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    flow(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    free(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    gap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    live(overrides?: CallOverrides): Promise<BigNumber>;
    out(arg0: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    pack(wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pot(overrides?: CallOverrides): Promise<string>;
    rely(usr: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    skim(ilk: PromiseOrValue<BytesLike>, urn: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    skip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    snip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    spot(overrides?: CallOverrides): Promise<string>;
    tag(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    thaw(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    vat(overrides?: CallOverrides): Promise<string>;
    vow(overrides?: CallOverrides): Promise<string>;
    wait(overrides?: CallOverrides): Promise<BigNumber>;
    wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    when(overrides?: CallOverrides): Promise<BigNumber>;
    callStatic: {
        Art(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        bag(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        "cage()"(overrides?: CallOverrides): Promise<void>;
        "cage(bytes32)"(ilk: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        cash(ilk: PromiseOrValue<BytesLike>, wad: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        cat(overrides?: CallOverrides): Promise<string>;
        cure(overrides?: CallOverrides): Promise<string>;
        debt(overrides?: CallOverrides): Promise<BigNumber>;
        deny(usr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        dog(overrides?: CallOverrides): Promise<string>;
        "file(bytes32,uint256)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        "file(bytes32,address)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        fix(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        flow(ilk: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        free(ilk: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        gap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        live(overrides?: CallOverrides): Promise<BigNumber>;
        out(arg0: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        pack(wad: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        pot(overrides?: CallOverrides): Promise<string>;
        rely(usr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        skim(ilk: PromiseOrValue<BytesLike>, urn: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        skip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        snip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        spot(overrides?: CallOverrides): Promise<string>;
        tag(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        thaw(overrides?: CallOverrides): Promise<void>;
        vat(overrides?: CallOverrides): Promise<string>;
        vow(overrides?: CallOverrides): Promise<string>;
        wait(overrides?: CallOverrides): Promise<BigNumber>;
        wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        when(overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "Cage()"(): Cage__EventFilter;
        "Cage(bytes32)"(ilk?: PromiseOrValue<BytesLike> | null): Cage_bytes32_EventFilter;
        "Cash(bytes32,address,uint256)"(ilk?: PromiseOrValue<BytesLike> | null, usr?: PromiseOrValue<string> | null, wad?: null): CashEventFilter;
        Cash(ilk?: PromiseOrValue<BytesLike> | null, usr?: PromiseOrValue<string> | null, wad?: null): CashEventFilter;
        "Deny(address)"(usr?: PromiseOrValue<string> | null): DenyEventFilter;
        Deny(usr?: PromiseOrValue<string> | null): DenyEventFilter;
        "File(bytes32,uint256)"(what?: PromiseOrValue<BytesLike> | null, data?: null): File_bytes32_uint256_EventFilter;
        "File(bytes32,address)"(what?: PromiseOrValue<BytesLike> | null, data?: null): File_bytes32_address_EventFilter;
        "Flow(bytes32)"(ilk?: PromiseOrValue<BytesLike> | null): FlowEventFilter;
        Flow(ilk?: PromiseOrValue<BytesLike> | null): FlowEventFilter;
        "Free(bytes32,address,uint256)"(ilk?: PromiseOrValue<BytesLike> | null, usr?: PromiseOrValue<string> | null, ink?: null): FreeEventFilter;
        Free(ilk?: PromiseOrValue<BytesLike> | null, usr?: PromiseOrValue<string> | null, ink?: null): FreeEventFilter;
        "Pack(address,uint256)"(usr?: PromiseOrValue<string> | null, wad?: null): PackEventFilter;
        Pack(usr?: PromiseOrValue<string> | null, wad?: null): PackEventFilter;
        "Rely(address)"(usr?: PromiseOrValue<string> | null): RelyEventFilter;
        Rely(usr?: PromiseOrValue<string> | null): RelyEventFilter;
        "Skim(bytes32,address,uint256,uint256)"(ilk?: PromiseOrValue<BytesLike> | null, urn?: PromiseOrValue<string> | null, wad?: null, art?: null): SkimEventFilter;
        Skim(ilk?: PromiseOrValue<BytesLike> | null, urn?: PromiseOrValue<string> | null, wad?: null, art?: null): SkimEventFilter;
        "Skip(bytes32,uint256,address,uint256,uint256,uint256)"(ilk?: PromiseOrValue<BytesLike> | null, id?: PromiseOrValue<BigNumberish> | null, usr?: PromiseOrValue<string> | null, tab?: null, lot?: null, art?: null): SkipEventFilter;
        Skip(ilk?: PromiseOrValue<BytesLike> | null, id?: PromiseOrValue<BigNumberish> | null, usr?: PromiseOrValue<string> | null, tab?: null, lot?: null, art?: null): SkipEventFilter;
        "Snip(bytes32,uint256,address,uint256,uint256,uint256)"(ilk?: PromiseOrValue<BytesLike> | null, id?: PromiseOrValue<BigNumberish> | null, usr?: PromiseOrValue<string> | null, tab?: null, lot?: null, art?: null): SnipEventFilter;
        Snip(ilk?: PromiseOrValue<BytesLike> | null, id?: PromiseOrValue<BigNumberish> | null, usr?: PromiseOrValue<string> | null, tab?: null, lot?: null, art?: null): SnipEventFilter;
        "Thaw()"(): ThawEventFilter;
        Thaw(): ThawEventFilter;
    };
    estimateGas: {
        Art(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        bag(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        "cage()"(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        "cage(bytes32)"(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        cash(ilk: PromiseOrValue<BytesLike>, wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        cat(overrides?: CallOverrides): Promise<BigNumber>;
        cure(overrides?: CallOverrides): Promise<BigNumber>;
        debt(overrides?: CallOverrides): Promise<BigNumber>;
        deny(usr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        dog(overrides?: CallOverrides): Promise<BigNumber>;
        "file(bytes32,uint256)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        "file(bytes32,address)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        fix(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        flow(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        free(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        gap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        live(overrides?: CallOverrides): Promise<BigNumber>;
        out(arg0: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        pack(wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        pot(overrides?: CallOverrides): Promise<BigNumber>;
        rely(usr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        skim(ilk: PromiseOrValue<BytesLike>, urn: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        skip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        snip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        spot(overrides?: CallOverrides): Promise<BigNumber>;
        tag(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        thaw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        vat(overrides?: CallOverrides): Promise<BigNumber>;
        vow(overrides?: CallOverrides): Promise<BigNumber>;
        wait(overrides?: CallOverrides): Promise<BigNumber>;
        wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        when(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        Art(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        bag(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "cage()"(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "cage(bytes32)"(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        cash(ilk: PromiseOrValue<BytesLike>, wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        cat(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        cure(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        debt(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        deny(usr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        dog(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "file(bytes32,uint256)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "file(bytes32,address)"(what: PromiseOrValue<BytesLike>, data: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        fix(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        flow(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        free(ilk: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        gap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        live(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        out(arg0: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        pack(wad: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pot(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rely(usr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        skim(ilk: PromiseOrValue<BytesLike>, urn: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        skip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        snip(ilk: PromiseOrValue<BytesLike>, id: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        spot(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tag(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        thaw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        vat(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        vow(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        wait(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        wards(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        when(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
