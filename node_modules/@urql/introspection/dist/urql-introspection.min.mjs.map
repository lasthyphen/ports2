{"version":3,"file":"urql-introspection.min.mjs","sources":["../src/getIntrospectedSchema.ts","../src/minifyIntrospectionQuery.ts"],"sourcesContent":["import {\n  IntrospectionQuery,\n  GraphQLSchema,\n  parse,\n  buildSchema,\n  execute,\n  getIntrospectionQuery,\n} from 'graphql';\n\nexport const getIntrospectedSchema = (\n  input: string | IntrospectionQuery | GraphQLSchema\n): IntrospectionQuery => {\n  if (typeof input === 'string') {\n    try {\n      input = JSON.parse(input);\n    } catch (_error) {\n      input = buildSchema(input as string);\n    }\n  }\n\n  if (typeof input === 'object' && '__schema' in input) {\n    return input;\n  }\n\n  const initialIntrospection: any = execute({\n    document: parse(getIntrospectionQuery({ descriptions: false })),\n    schema: input as GraphQLSchema,\n  });\n\n  if (!initialIntrospection.data || !initialIntrospection.data.__schema) {\n    throw new TypeError(\n      'GraphQL could not generate an IntrospectionQuery from the given schema.'\n    );\n  }\n\n  return initialIntrospection.data as IntrospectionQuery;\n};\n","import {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionTypeRef,\n  IntrospectionInputValue,\n} from 'graphql';\n\nlet _includeScalars = false;\nlet _includeEnums = false;\nlet _includeInputs = false;\nlet _hasAnyType = false;\n\nconst anyType: IntrospectionTypeRef = {\n  kind: 'SCALAR',\n  name: 'Any',\n};\n\nconst mapType = (fromType: any): IntrospectionTypeRef => {\n  switch (fromType.kind) {\n    case 'NON_NULL':\n    case 'LIST':\n      return {\n        kind: fromType.kind,\n        ofType: mapType(fromType.ofType),\n      };\n\n    case 'SCALAR':\n      _hasAnyType = _hasAnyType || _includeScalars;\n      return _includeScalars ? fromType : anyType;\n\n    case 'INPUT_OBJECT':\n      _hasAnyType = _hasAnyType || _includeInputs;\n      return _includeInputs ? fromType : anyType;\n\n    case 'ENUM':\n      _hasAnyType = _hasAnyType || _includeEnums;\n      return _includeEnums ? fromType : anyType;\n\n    case 'OBJECT':\n    case 'INTERFACE':\n    case 'UNION':\n      return fromType;\n\n    default:\n      throw new TypeError(\n        `Unrecognized type reference of type: ${(fromType as any).kind}.`\n      );\n  }\n};\n\nconst minifyIntrospectionType = (\n  type: IntrospectionType\n): IntrospectionType => {\n  switch (type.kind) {\n    case 'SCALAR':\n      return {\n        kind: 'SCALAR',\n        name: type.name,\n      };\n\n    case 'ENUM':\n      return {\n        kind: 'ENUM',\n        name: type.name,\n        enumValues: type.enumValues.map(\n          value =>\n            ({\n              name: value.name,\n            } as any)\n        ),\n      };\n\n    case 'INPUT_OBJECT': {\n      return {\n        kind: 'INPUT_OBJECT',\n        name: type.name,\n        inputFields: type.inputFields.map(\n          field =>\n            ({\n              name: field.name,\n              type: mapType(field.type),\n              defaultValue: field.defaultValue || undefined,\n            } as IntrospectionInputValue)\n        ),\n      };\n    }\n\n    case 'OBJECT':\n      return {\n        kind: 'OBJECT',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            } as any)\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n      };\n\n    case 'INTERFACE':\n      return {\n        kind: 'INTERFACE',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            } as any)\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n        possibleTypes:\n          type.possibleTypes &&\n          type.possibleTypes.map(type => ({\n            kind: type.kind,\n            name: type.name,\n          })),\n      };\n\n    case 'UNION':\n      return {\n        kind: 'UNION',\n        name: type.name,\n        possibleTypes: type.possibleTypes.map(type => ({\n          kind: type.kind,\n          name: type.name,\n        })),\n      };\n\n    default:\n      return type;\n  }\n};\n\nexport interface MinifySchemaOptions {\n  /** Includes scalar names (instead of an `Any` replacement) in the output when enabled. */\n  includeScalars?: boolean;\n  /** Includes enums (instead of an `Any` replacement) in the output when enabled. */\n  includeEnums?: boolean;\n  /** Includes all input objects (instead of an `Any` replacement) in the output when enabled. */\n  includeInputs?: boolean;\n  /** Includes all directives in the output when enabled. */\n  includeDirectives?: boolean;\n}\n\n/** Removes extraneous information from introspected schema data to minify it and prepare it for use on the client-side. */\nexport const minifyIntrospectionQuery = (\n  schema: IntrospectionQuery,\n  opts: MinifySchemaOptions = {}\n): IntrospectionQuery => {\n  if (!schema || !('__schema' in schema)) {\n    throw new TypeError('Expected to receive an IntrospectionQuery.');\n  }\n\n  _hasAnyType = false;\n  _includeScalars = !!opts.includeScalars;\n  _includeEnums = !!opts.includeEnums;\n  _includeInputs = !!opts.includeInputs;\n\n  const {\n    __schema: { queryType, mutationType, subscriptionType, types, directives },\n  } = schema;\n\n  const minifiedTypes = types\n    .filter(type => {\n      switch (type.name) {\n        case '__Directive':\n        case '__DirectiveLocation':\n        case '__EnumValue':\n        case '__InputValue':\n        case '__Field':\n        case '__Type':\n        case '__TypeKind':\n        case '__Schema':\n          return false;\n        default:\n          return (\n            (_includeScalars && type.kind === 'SCALAR') ||\n            (_includeEnums && type.kind === 'ENUM') ||\n            (_includeInputs && type.kind === 'INPUT_OBJECT') ||\n            type.kind === 'OBJECT' ||\n            type.kind === 'INTERFACE' ||\n            type.kind === 'UNION'\n          );\n      }\n    })\n    .map(minifyIntrospectionType);\n\n  const minifiedDirectives = (directives || []).map(directive => ({\n    name: directive.name,\n    isRepeatable: directive.isRepeatable ? true : undefined,\n    locations: directive.locations,\n    args: directive.args.map(\n      arg =>\n        ({\n          name: arg.name,\n          type: mapType(arg.type),\n          defaultValue: arg.defaultValue || undefined,\n        } as IntrospectionInputValue)\n    ),\n  }));\n\n  if (!_includeScalars || !_includeEnums || !_includeInputs || _hasAnyType) {\n    minifiedTypes.push({ kind: 'SCALAR', name: anyType.name });\n  }\n\n  return {\n    __schema: {\n      queryType,\n      mutationType,\n      subscriptionType,\n      types: minifiedTypes,\n      directives: opts.includeDirectives ? minifiedDirectives : [],\n    },\n  };\n};\n"],"names":["getIntrospectedSchema","input","JSON","parse","_error","buildSchema","schema","TypeError","let","_includeScalars","_includeEnums","_includeInputs","_hasAnyType","anyType","kind","name","mapType","fromType","ofType","minifyIntrospectionType","type","field","defaultValue","undefined","arg","minifyIntrospectionQuery","opts","includeScalars","includeEnums","includeInputs","schema_schema","__schema","queryType","mutationType","subscriptionType","directives","types","minifiedDirectives","map","directive","minifiedTypes","push"],"mappings":"kGASAA,EAAAC,GAGE,GAAA,iBAAAA,MAEIA,EAAAC,KAAAC,MAAAF,GACA,MAAAG,GACAH,EAAAI,EAAAJ,yCAKF,OAAAA,4CAKAK,OAAAL,iCAIA,MAAA,IAAAM,UAAA,yFCvBJC,IAAAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EAEAC,EAAA,CACEC,KAAA,SACAC,KAAA,gBAGFC,EAAAC,kBAEI,IAAA,WACA,IAAA,0BAGIC,OAAAF,EAAAC,EAAAC,SAGJ,IAAA,gBACEN,EAAAA,GAAAH,QAGF,IAAA,sBACEG,EAAAA,GAAAD,QAGF,IAAA,cACEC,EAAAA,GAAAF,QAGF,IAAA,SACA,IAAA,YACA,IAAA,QACE,OAAAO,EAEF,0FAOJE,EAAAC,kBAII,IAAA,gBAEIN,KAAA,sBAIJ,IAAA,cAEIA,KAAA,8GAYAA,KAAA,yFAMMM,KAAAJ,EAAAK,EAAAD,MACAE,aAAAD,EAAAC,mBAAAC,OAMV,IAAA,gBAEIT,KAAA,wJAWUM,KAAAJ,EAAAQ,EAAAJ,4EAONN,KAAA,6BAKR,IAAA,mBAEIA,KAAA,2JAWUM,KAAAJ,EAAAQ,EAAAJ,4EAONN,KAAA,gIAWR,IAAA,eAEIA,KAAA,uGAQJ,QACE,OAAAM,GAgBNK,SAAAA,EAAAnB,EAAAoB,qBAAA,0BAKI,MAAA,IAAAnB,UAAA,mDAIFE,IAAAiB,EAAAC,eACAjB,IAAAgB,EAAAE,aACAjB,IAAAe,EAAAG,cAEA,IAAAC,EAAAxB,EAAAyB,SAAAC,EAAAF,EAAAE,UAAAC,EAAAH,EAAAG,aAAAC,EAAAJ,EAAAI,iBAAAC,EAAAL,EAAAK,aAAAL,EAAAM,yCAOM,IAAA,cACA,IAAA,sBACA,IAAA,cACA,IAAA,eACA,IAAA,UACA,IAAA,SACA,IAAA,aACA,IAAA,WACE,OAAA,EACF,qCAGI1B,GAAA,SAAAU,EAAAN,MACAH,GAAA,iBAAAS,EAAAN,+CAGA,UAAAM,EAAAN,gBAMVuB,GAAAF,GAAA,IAAAG,KAAA,SAAAC,GAAA,MAAA,yHAQQnB,KAAAJ,EAAAQ,EAAAJ,MACAE,aAAAE,EAAAF,mBAAAC,8BAMNiB,EAAAC,KAAA,CAAA3B,KAAA,SAAAC,KAAAF,EAAAE,QAIAgB,SAAA,+CAIEK,MAAAI"}