{"version":3,"file":"urql-introspection.js","sources":["../src/getIntrospectedSchema.ts","../src/minifyIntrospectionQuery.ts"],"sourcesContent":["import {\n  IntrospectionQuery,\n  GraphQLSchema,\n  parse,\n  buildSchema,\n  execute,\n  getIntrospectionQuery,\n} from 'graphql';\n\nexport const getIntrospectedSchema = (\n  input: string | IntrospectionQuery | GraphQLSchema\n): IntrospectionQuery => {\n  if (typeof input === 'string') {\n    try {\n      input = JSON.parse(input);\n    } catch (_error) {\n      input = buildSchema(input as string);\n    }\n  }\n\n  if (typeof input === 'object' && '__schema' in input) {\n    return input;\n  }\n\n  const initialIntrospection: any = execute({\n    document: parse(getIntrospectionQuery({ descriptions: false })),\n    schema: input as GraphQLSchema,\n  });\n\n  if (!initialIntrospection.data || !initialIntrospection.data.__schema) {\n    throw new TypeError(\n      'GraphQL could not generate an IntrospectionQuery from the given schema.'\n    );\n  }\n\n  return initialIntrospection.data as IntrospectionQuery;\n};\n","import {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionTypeRef,\n  IntrospectionInputValue,\n} from 'graphql';\n\nlet _includeScalars = false;\nlet _includeEnums = false;\nlet _includeInputs = false;\nlet _hasAnyType = false;\n\nconst anyType: IntrospectionTypeRef = {\n  kind: 'SCALAR',\n  name: 'Any',\n};\n\nconst mapType = (fromType: any): IntrospectionTypeRef => {\n  switch (fromType.kind) {\n    case 'NON_NULL':\n    case 'LIST':\n      return {\n        kind: fromType.kind,\n        ofType: mapType(fromType.ofType),\n      };\n\n    case 'SCALAR':\n      _hasAnyType = _hasAnyType || _includeScalars;\n      return _includeScalars ? fromType : anyType;\n\n    case 'INPUT_OBJECT':\n      _hasAnyType = _hasAnyType || _includeInputs;\n      return _includeInputs ? fromType : anyType;\n\n    case 'ENUM':\n      _hasAnyType = _hasAnyType || _includeEnums;\n      return _includeEnums ? fromType : anyType;\n\n    case 'OBJECT':\n    case 'INTERFACE':\n    case 'UNION':\n      return fromType;\n\n    default:\n      throw new TypeError(\n        `Unrecognized type reference of type: ${(fromType as any).kind}.`\n      );\n  }\n};\n\nconst minifyIntrospectionType = (\n  type: IntrospectionType\n): IntrospectionType => {\n  switch (type.kind) {\n    case 'SCALAR':\n      return {\n        kind: 'SCALAR',\n        name: type.name,\n      };\n\n    case 'ENUM':\n      return {\n        kind: 'ENUM',\n        name: type.name,\n        enumValues: type.enumValues.map(\n          value =>\n            ({\n              name: value.name,\n            } as any)\n        ),\n      };\n\n    case 'INPUT_OBJECT': {\n      return {\n        kind: 'INPUT_OBJECT',\n        name: type.name,\n        inputFields: type.inputFields.map(\n          field =>\n            ({\n              name: field.name,\n              type: mapType(field.type),\n              defaultValue: field.defaultValue || undefined,\n            } as IntrospectionInputValue)\n        ),\n      };\n    }\n\n    case 'OBJECT':\n      return {\n        kind: 'OBJECT',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            } as any)\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n      };\n\n    case 'INTERFACE':\n      return {\n        kind: 'INTERFACE',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            } as any)\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n        possibleTypes:\n          type.possibleTypes &&\n          type.possibleTypes.map(type => ({\n            kind: type.kind,\n            name: type.name,\n          })),\n      };\n\n    case 'UNION':\n      return {\n        kind: 'UNION',\n        name: type.name,\n        possibleTypes: type.possibleTypes.map(type => ({\n          kind: type.kind,\n          name: type.name,\n        })),\n      };\n\n    default:\n      return type;\n  }\n};\n\nexport interface MinifySchemaOptions {\n  /** Includes scalar names (instead of an `Any` replacement) in the output when enabled. */\n  includeScalars?: boolean;\n  /** Includes enums (instead of an `Any` replacement) in the output when enabled. */\n  includeEnums?: boolean;\n  /** Includes all input objects (instead of an `Any` replacement) in the output when enabled. */\n  includeInputs?: boolean;\n  /** Includes all directives in the output when enabled. */\n  includeDirectives?: boolean;\n}\n\n/** Removes extraneous information from introspected schema data to minify it and prepare it for use on the client-side. */\nexport const minifyIntrospectionQuery = (\n  schema: IntrospectionQuery,\n  opts: MinifySchemaOptions = {}\n): IntrospectionQuery => {\n  if (!schema || !('__schema' in schema)) {\n    throw new TypeError('Expected to receive an IntrospectionQuery.');\n  }\n\n  _hasAnyType = false;\n  _includeScalars = !!opts.includeScalars;\n  _includeEnums = !!opts.includeEnums;\n  _includeInputs = !!opts.includeInputs;\n\n  const {\n    __schema: { queryType, mutationType, subscriptionType, types, directives },\n  } = schema;\n\n  const minifiedTypes = types\n    .filter(type => {\n      switch (type.name) {\n        case '__Directive':\n        case '__DirectiveLocation':\n        case '__EnumValue':\n        case '__InputValue':\n        case '__Field':\n        case '__Type':\n        case '__TypeKind':\n        case '__Schema':\n          return false;\n        default:\n          return (\n            (_includeScalars && type.kind === 'SCALAR') ||\n            (_includeEnums && type.kind === 'ENUM') ||\n            (_includeInputs && type.kind === 'INPUT_OBJECT') ||\n            type.kind === 'OBJECT' ||\n            type.kind === 'INTERFACE' ||\n            type.kind === 'UNION'\n          );\n      }\n    })\n    .map(minifyIntrospectionType);\n\n  const minifiedDirectives = (directives || []).map(directive => ({\n    name: directive.name,\n    isRepeatable: directive.isRepeatable ? true : undefined,\n    locations: directive.locations,\n    args: directive.args.map(\n      arg =>\n        ({\n          name: arg.name,\n          type: mapType(arg.type),\n          defaultValue: arg.defaultValue || undefined,\n        } as IntrospectionInputValue)\n    ),\n  }));\n\n  if (!_includeScalars || !_includeEnums || !_includeInputs || _hasAnyType) {\n    minifiedTypes.push({ kind: 'SCALAR', name: anyType.name });\n  }\n\n  return {\n    __schema: {\n      queryType,\n      mutationType,\n      subscriptionType,\n      types: minifiedTypes,\n      directives: opts.includeDirectives ? minifiedDirectives : [],\n    },\n  };\n};\n"],"names":["getIntrospectedSchema","input","JSON","parse","_error","buildSchema","schema","TypeError","let","_includeScalars","_includeEnums","_includeInputs","_hasAnyType","const","anyType","kind","name","mapType","fromType","ofType","minifyIntrospectionType","type","field","defaultValue","undefined","arg","minifyIntrospectionQuery","opts","includeScalars","includeEnums","includeInputs","schema_schema","__schema","queryType","mutationType","subscriptionType","types","directives","minifiedDirectives","map","directive","minifiedTypes","push"],"mappings":"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"}