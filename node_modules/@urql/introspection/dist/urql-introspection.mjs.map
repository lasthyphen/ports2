{"version":3,"file":"urql-introspection.mjs","sources":["../src/getIntrospectedSchema.ts","../src/minifyIntrospectionQuery.ts"],"sourcesContent":["import {\n  IntrospectionQuery,\n  GraphQLSchema,\n  parse,\n  buildSchema,\n  execute,\n  getIntrospectionQuery,\n} from 'graphql';\n\nexport const getIntrospectedSchema = (\n  input: string | IntrospectionQuery | GraphQLSchema\n): IntrospectionQuery => {\n  if (typeof input === 'string') {\n    try {\n      input = JSON.parse(input);\n    } catch (_error) {\n      input = buildSchema(input as string);\n    }\n  }\n\n  if (typeof input === 'object' && '__schema' in input) {\n    return input;\n  }\n\n  const initialIntrospection: any = execute({\n    document: parse(getIntrospectionQuery({ descriptions: false })),\n    schema: input as GraphQLSchema,\n  });\n\n  if (!initialIntrospection.data || !initialIntrospection.data.__schema) {\n    throw new TypeError(\n      'GraphQL could not generate an IntrospectionQuery from the given schema.'\n    );\n  }\n\n  return initialIntrospection.data as IntrospectionQuery;\n};\n","import {\n  IntrospectionQuery,\n  IntrospectionType,\n  IntrospectionTypeRef,\n  IntrospectionInputValue,\n} from 'graphql';\n\nlet _includeScalars = false;\nlet _includeEnums = false;\nlet _includeInputs = false;\nlet _hasAnyType = false;\n\nconst anyType: IntrospectionTypeRef = {\n  kind: 'SCALAR',\n  name: 'Any',\n};\n\nconst mapType = (fromType: any): IntrospectionTypeRef => {\n  switch (fromType.kind) {\n    case 'NON_NULL':\n    case 'LIST':\n      return {\n        kind: fromType.kind,\n        ofType: mapType(fromType.ofType),\n      };\n\n    case 'SCALAR':\n      _hasAnyType = _hasAnyType || _includeScalars;\n      return _includeScalars ? fromType : anyType;\n\n    case 'INPUT_OBJECT':\n      _hasAnyType = _hasAnyType || _includeInputs;\n      return _includeInputs ? fromType : anyType;\n\n    case 'ENUM':\n      _hasAnyType = _hasAnyType || _includeEnums;\n      return _includeEnums ? fromType : anyType;\n\n    case 'OBJECT':\n    case 'INTERFACE':\n    case 'UNION':\n      return fromType;\n\n    default:\n      throw new TypeError(\n        `Unrecognized type reference of type: ${(fromType as any).kind}.`\n      );\n  }\n};\n\nconst minifyIntrospectionType = (\n  type: IntrospectionType\n): IntrospectionType => {\n  switch (type.kind) {\n    case 'SCALAR':\n      return {\n        kind: 'SCALAR',\n        name: type.name,\n      };\n\n    case 'ENUM':\n      return {\n        kind: 'ENUM',\n        name: type.name,\n        enumValues: type.enumValues.map(\n          value =>\n            ({\n              name: value.name,\n            } as any)\n        ),\n      };\n\n    case 'INPUT_OBJECT': {\n      return {\n        kind: 'INPUT_OBJECT',\n        name: type.name,\n        inputFields: type.inputFields.map(\n          field =>\n            ({\n              name: field.name,\n              type: mapType(field.type),\n              defaultValue: field.defaultValue || undefined,\n            } as IntrospectionInputValue)\n        ),\n      };\n    }\n\n    case 'OBJECT':\n      return {\n        kind: 'OBJECT',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            } as any)\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n      };\n\n    case 'INTERFACE':\n      return {\n        kind: 'INTERFACE',\n        name: type.name,\n        fields: type.fields.map(\n          field =>\n            ({\n              name: field.name,\n              type: field.type && mapType(field.type),\n              args:\n                field.args &&\n                field.args.map(arg => ({\n                  name: arg.name,\n                  type: mapType(arg.type),\n                })),\n            } as any)\n        ),\n        interfaces:\n          type.interfaces &&\n          type.interfaces.map(int => ({\n            kind: 'INTERFACE',\n            name: int.name,\n          })),\n        possibleTypes:\n          type.possibleTypes &&\n          type.possibleTypes.map(type => ({\n            kind: type.kind,\n            name: type.name,\n          })),\n      };\n\n    case 'UNION':\n      return {\n        kind: 'UNION',\n        name: type.name,\n        possibleTypes: type.possibleTypes.map(type => ({\n          kind: type.kind,\n          name: type.name,\n        })),\n      };\n\n    default:\n      return type;\n  }\n};\n\nexport interface MinifySchemaOptions {\n  /** Includes scalar names (instead of an `Any` replacement) in the output when enabled. */\n  includeScalars?: boolean;\n  /** Includes enums (instead of an `Any` replacement) in the output when enabled. */\n  includeEnums?: boolean;\n  /** Includes all input objects (instead of an `Any` replacement) in the output when enabled. */\n  includeInputs?: boolean;\n  /** Includes all directives in the output when enabled. */\n  includeDirectives?: boolean;\n}\n\n/** Removes extraneous information from introspected schema data to minify it and prepare it for use on the client-side. */\nexport const minifyIntrospectionQuery = (\n  schema: IntrospectionQuery,\n  opts: MinifySchemaOptions = {}\n): IntrospectionQuery => {\n  if (!schema || !('__schema' in schema)) {\n    throw new TypeError('Expected to receive an IntrospectionQuery.');\n  }\n\n  _hasAnyType = false;\n  _includeScalars = !!opts.includeScalars;\n  _includeEnums = !!opts.includeEnums;\n  _includeInputs = !!opts.includeInputs;\n\n  const {\n    __schema: { queryType, mutationType, subscriptionType, types, directives },\n  } = schema;\n\n  const minifiedTypes = types\n    .filter(type => {\n      switch (type.name) {\n        case '__Directive':\n        case '__DirectiveLocation':\n        case '__EnumValue':\n        case '__InputValue':\n        case '__Field':\n        case '__Type':\n        case '__TypeKind':\n        case '__Schema':\n          return false;\n        default:\n          return (\n            (_includeScalars && type.kind === 'SCALAR') ||\n            (_includeEnums && type.kind === 'ENUM') ||\n            (_includeInputs && type.kind === 'INPUT_OBJECT') ||\n            type.kind === 'OBJECT' ||\n            type.kind === 'INTERFACE' ||\n            type.kind === 'UNION'\n          );\n      }\n    })\n    .map(minifyIntrospectionType);\n\n  const minifiedDirectives = (directives || []).map(directive => ({\n    name: directive.name,\n    isRepeatable: directive.isRepeatable ? true : undefined,\n    locations: directive.locations,\n    args: directive.args.map(\n      arg =>\n        ({\n          name: arg.name,\n          type: mapType(arg.type),\n          defaultValue: arg.defaultValue || undefined,\n        } as IntrospectionInputValue)\n    ),\n  }));\n\n  if (!_includeScalars || !_includeEnums || !_includeInputs || _hasAnyType) {\n    minifiedTypes.push({ kind: 'SCALAR', name: anyType.name });\n  }\n\n  return {\n    __schema: {\n      queryType,\n      mutationType,\n      subscriptionType,\n      types: minifiedTypes,\n      directives: opts.includeDirectives ? minifiedDirectives : [],\n    },\n  };\n};\n"],"names":["getIntrospectedSchema","input","JSON","parse","_error","buildSchema","schema","TypeError","let","_includeScalars","_includeEnums","_includeInputs","_hasAnyType","const","anyType","kind","name","mapType","fromType","ofType","minifyIntrospectionType","type","field","defaultValue","undefined","arg","minifyIntrospectionQuery","opts","includeScalars","includeEnums","includeInputs","schema_schema","__schema","queryType","mutationType","subscriptionType","directives","types","minifiedDirectives","map","directive","minifiedTypes","push"],"mappings":";;SASAA,sBAAAC;EAGE,IAAA,mBAAAA;;MAEIA,IAAAC,KAAAC,MAAAF;MACA,OAAAG;MACAH,IAAAI,EAAAJ;;;;IAKF,OAAAA;;;;;;IAKAK,QAAAL;;;IAIA,MAAA,IAAAM,UAAA;;;;;ACvBJC,IAAAC,KAAA;;AACAD,IAAAE,KAAA;;AACAF,IAAAG,KAAA;;AACAH,IAAAI,KAAA;;AAEAC,IAAAC,IAAA;EACEC,MAAA;EACAC,MAAA;;;SAGFC,QAAAC;;GAEI,KAAA;GACA,KAAA;;;MAGIC,QAAAF,QAAAC,EAAAC;;;GAGJ,KAAA;IACEP,IAAAA,KAAAH;;;GAGF,KAAA;IACEG,IAAAA,KAAAD;;;GAGF,KAAA;IACEC,IAAAA,KAAAF;;;GAGF,KAAA;GACA,KAAA;GACA,KAAA;IACE,OAAAQ;;GAEF;;;;;SAOJE,wBAAAC;;GAII,KAAA;;MAEIN,MAAA;;;;GAIJ,KAAA;;MAEIA,MAAA;;;;;;;;;;;MAYAA,MAAA;;;;;UAMMM,MAAAJ,QAAAK,EAAAD;UACAE,cAAAD,EAAAC,qBAAAC;;;;;GAMV,KAAA;;MAEIT,MAAA;;;;;;;;;cAWUM,MAAAJ,QAAAQ,EAAAJ;;;;;;;UAONN,MAAA;;;;;;GAKR,KAAA;;MAEIA,MAAA;;;;;;;;;cAWUM,MAAAJ,QAAAQ,EAAAJ;;;;;;;UAONN,MAAA;;;;;;;;;;;;GAWR,KAAA;;MAEIA,MAAA;;;;;;;;;;GAQJ;IACE,OAAAM;;;;AAgBNK,SAAAA,yBAAApB,GAAAqB;;QAAA;;;IAKI,MAAA,IAAApB,UAAA;;;EAIFE,MAAAkB,EAAAC;EACAlB,MAAAiB,EAAAE;EACAlB,MAAAgB,EAAAG;EAEA,IAAAC,IAAAzB,EAAA0B;EAAA,IAAAC,IAAAF,EAAAE;EAAA,IAAAC,IAAAH,EAAAG;EAAA,IAAAC,IAAAJ,EAAAI;EAAA,IAAAC,IAAAL,EAAAK;UAAAL,EAAAM;;KAOM,KAAA;KACA,KAAA;KACA,KAAA;KACA,KAAA;KACA,KAAA;KACA,KAAA;KACA,KAAA;KACA,KAAA;MACE,QAAA;;KACF;yCAGI3B,KAAA,WAAAW,EAAAN,QACAJ,KAAA,mBAAAU,EAAAN,yDAGA,YAAAM,EAAAN;;;EAMVuB,IAAAA,KAAAF,KAAA,IAAAG,KAAA,SAAAC;IAAA,OAAA;;;;;;;UAQQnB,MAAAJ,QAAAQ,EAAAJ;UACAE,cAAAE,EAAAF,qBAAAC;;;;;;IAMNiB,EAAAC,KAAA;MAAA3B,MAAA;MAAAC,MAAAF,EAAAE;;;;IAIAgB,UAAA;;;;MAIEK,OAAAI;;;;;;"}