Object.defineProperty(exports, '__esModule', {
  value: true
});

var graphql = require('graphql');

function getIntrospectedSchema(input) {
  if (typeof input === 'string') {
    try {
      input = JSON.parse(input);
    } catch (_error) {
      input = graphql.buildSchema(input);
    }
  }

  if (typeof input === 'object' && '__schema' in input) {
    return input;
  }

  var initialIntrospection = graphql.execute({
    document: graphql.parse(graphql.getIntrospectionQuery({
      descriptions: false
    })),
    schema: input
  });

  if (!initialIntrospection.data || !initialIntrospection.data.__schema) {
    throw new TypeError('GraphQL could not generate an IntrospectionQuery from the given schema.');
  }

  return initialIntrospection.data;
}

var _includeScalars = false;
var _includeEnums = false;
var _includeInputs = false;
var _hasAnyType = false;
var anyType = {
  kind: 'SCALAR',
  name: 'Any'
};

function mapType(fromType) {
  switch (fromType.kind) {
    case 'NON_NULL':
    case 'LIST':
      return {
        kind: fromType.kind,
        ofType: mapType(fromType.ofType)
      };

    case 'SCALAR':
      _hasAnyType = _hasAnyType || _includeScalars;
      return _includeScalars ? fromType : anyType;

    case 'INPUT_OBJECT':
      _hasAnyType = _hasAnyType || _includeInputs;
      return _includeInputs ? fromType : anyType;

    case 'ENUM':
      _hasAnyType = _hasAnyType || _includeEnums;
      return _includeEnums ? fromType : anyType;

    case 'OBJECT':
    case 'INTERFACE':
    case 'UNION':
      return fromType;

    default:
      throw new TypeError("Unrecognized type reference of type: " + fromType.kind + ".");
  }
}

function minifyIntrospectionType(type) {
  switch (type.kind) {
    case 'SCALAR':
      return {
        kind: 'SCALAR',
        name: type.name
      };

    case 'ENUM':
      return {
        kind: 'ENUM',
        name: type.name,
        enumValues: type.enumValues.map(function (value) {
          return {
            name: value.name
          };
        })
      };

    case 'INPUT_OBJECT':
      {
        return {
          kind: 'INPUT_OBJECT',
          name: type.name,
          inputFields: type.inputFields.map(function (field) {
            return {
              name: field.name,
              type: mapType(field.type),
              defaultValue: field.defaultValue || undefined
            };
          })
        };
      }

    case 'OBJECT':
      return {
        kind: 'OBJECT',
        name: type.name,
        fields: type.fields.map(function (field) {
          return {
            name: field.name,
            type: field.type && mapType(field.type),
            args: field.args && field.args.map(function (arg) {
              return {
                name: arg.name,
                type: mapType(arg.type)
              };
            })
          };
        }),
        interfaces: type.interfaces && type.interfaces.map(function (int) {
          return {
            kind: 'INTERFACE',
            name: int.name
          };
        })
      };

    case 'INTERFACE':
      return {
        kind: 'INTERFACE',
        name: type.name,
        fields: type.fields.map(function (field) {
          return {
            name: field.name,
            type: field.type && mapType(field.type),
            args: field.args && field.args.map(function (arg) {
              return {
                name: arg.name,
                type: mapType(arg.type)
              };
            })
          };
        }),
        interfaces: type.interfaces && type.interfaces.map(function (int) {
          return {
            kind: 'INTERFACE',
            name: int.name
          };
        }),
        possibleTypes: type.possibleTypes && type.possibleTypes.map(function (type) {
          return {
            kind: type.kind,
            name: type.name
          };
        })
      };

    case 'UNION':
      return {
        kind: 'UNION',
        name: type.name,
        possibleTypes: type.possibleTypes.map(function (type) {
          return {
            kind: type.kind,
            name: type.name
          };
        })
      };

    default:
      return type;
  }
}

function minifyIntrospectionQuery(schema, opts) {
  if (opts === void 0) opts = {};

  if (!schema || !('__schema' in schema)) {
    throw new TypeError('Expected to receive an IntrospectionQuery.');
  }

  _hasAnyType = false;
  _includeScalars = !!opts.includeScalars;
  _includeEnums = !!opts.includeEnums;
  _includeInputs = !!opts.includeInputs;
  var schema_schema = schema.__schema;
  var queryType = schema_schema.queryType;
  var mutationType = schema_schema.mutationType;
  var subscriptionType = schema_schema.subscriptionType;
  var types = schema_schema.types;
  var directives = schema_schema.directives;
  var minifiedTypes = types.filter(function (type) {
    switch (type.name) {
      case '__Directive':
      case '__DirectiveLocation':
      case '__EnumValue':
      case '__InputValue':
      case '__Field':
      case '__Type':
      case '__TypeKind':
      case '__Schema':
        return false;

      default:
        return _includeScalars && type.kind === 'SCALAR' || _includeEnums && type.kind === 'ENUM' || _includeInputs && type.kind === 'INPUT_OBJECT' || type.kind === 'OBJECT' || type.kind === 'INTERFACE' || type.kind === 'UNION';
    }
  }).map(minifyIntrospectionType);
  var minifiedDirectives = (directives || []).map(function (directive) {
    return {
      name: directive.name,
      isRepeatable: directive.isRepeatable ? true : undefined,
      locations: directive.locations,
      args: directive.args.map(function (arg) {
        return {
          name: arg.name,
          type: mapType(arg.type),
          defaultValue: arg.defaultValue || undefined
        };
      })
    };
  });

  if (!_includeScalars || !_includeEnums || !_includeInputs || _hasAnyType) {
    minifiedTypes.push({
      kind: 'SCALAR',
      name: anyType.name
    });
  }

  return {
    __schema: {
      queryType: queryType,
      mutationType: mutationType,
      subscriptionType: subscriptionType,
      types: minifiedTypes,
      directives: opts.includeDirectives ? minifiedDirectives : []
    }
  };
}

exports.getIntrospectedSchema = getIntrospectedSchema;
exports.minifyIntrospectionQuery = minifyIntrospectionQuery;
//# sourceMappingURL=urql-introspection.js.map
