import { buildSchema as e, execute as n, parse as a, getIntrospectionQuery as t } from "graphql";

function getIntrospectedSchema(r) {
  if ("string" == typeof r) {
    try {
      r = JSON.parse(r);
    } catch (n) {
      r = e(r);
    }
  }
  if ("object" == typeof r && "__schema" in r) {
    return r;
  }
  var i = n({
    document: a(t({
      descriptions: !1
    })),
    schema: r
  });
  if (!i.data || !i.data.__schema) {
    throw new TypeError("GraphQL could not generate an IntrospectionQuery from the given schema.");
  }
  return i.data;
}

var r = !1;

var i = !1;

var p = !1;

var s = !1;

var c = {
  kind: "SCALAR",
  name: "Any"
};

function mapType(e) {
  switch (e.kind) {
   case "NON_NULL":
   case "LIST":
    return {
      kind: e.kind,
      ofType: mapType(e.ofType)
    };

   case "SCALAR":
    s = s || r;
    return r ? e : c;

   case "INPUT_OBJECT":
    s = s || p;
    return p ? e : c;

   case "ENUM":
    s = s || i;
    return i ? e : c;

   case "OBJECT":
   case "INTERFACE":
   case "UNION":
    return e;

   default:
    throw new TypeError("Unrecognized type reference of type: " + e.kind + ".");
  }
}

function minifyIntrospectionType(e) {
  switch (e.kind) {
   case "SCALAR":
    return {
      kind: "SCALAR",
      name: e.name
    };

   case "ENUM":
    return {
      kind: "ENUM",
      name: e.name,
      enumValues: e.enumValues.map((function(e) {
        return {
          name: e.name
        };
      }))
    };

   case "INPUT_OBJECT":
    return {
      kind: "INPUT_OBJECT",
      name: e.name,
      inputFields: e.inputFields.map((function(e) {
        return {
          name: e.name,
          type: mapType(e.type),
          defaultValue: e.defaultValue || void 0
        };
      }))
    };

   case "OBJECT":
    return {
      kind: "OBJECT",
      name: e.name,
      fields: e.fields.map((function(e) {
        return {
          name: e.name,
          type: e.type && mapType(e.type),
          args: e.args && e.args.map((function(e) {
            return {
              name: e.name,
              type: mapType(e.type)
            };
          }))
        };
      })),
      interfaces: e.interfaces && e.interfaces.map((function(e) {
        return {
          kind: "INTERFACE",
          name: e.name
        };
      }))
    };

   case "INTERFACE":
    return {
      kind: "INTERFACE",
      name: e.name,
      fields: e.fields.map((function(e) {
        return {
          name: e.name,
          type: e.type && mapType(e.type),
          args: e.args && e.args.map((function(e) {
            return {
              name: e.name,
              type: mapType(e.type)
            };
          }))
        };
      })),
      interfaces: e.interfaces && e.interfaces.map((function(e) {
        return {
          kind: "INTERFACE",
          name: e.name
        };
      })),
      possibleTypes: e.possibleTypes && e.possibleTypes.map((function(e) {
        return {
          kind: e.kind,
          name: e.name
        };
      }))
    };

   case "UNION":
    return {
      kind: "UNION",
      name: e.name,
      possibleTypes: e.possibleTypes.map((function(e) {
        return {
          kind: e.kind,
          name: e.name
        };
      }))
    };

   default:
    return e;
  }
}

function minifyIntrospectionQuery(e, n) {
  if (void 0 === n) {
    n = {};
  }
  if (!e || !("__schema" in e)) {
    throw new TypeError("Expected to receive an IntrospectionQuery.");
  }
  s = !1;
  r = !!n.includeScalars;
  i = !!n.includeEnums;
  p = !!n.includeInputs;
  var a = e.__schema;
  var t = a.queryType;
  var u = a.mutationType;
  var m = a.subscriptionType;
  var o = a.directives;
  var d = a.types.filter((function(e) {
    switch (e.name) {
     case "__Directive":
     case "__DirectiveLocation":
     case "__EnumValue":
     case "__InputValue":
     case "__Field":
     case "__Type":
     case "__TypeKind":
     case "__Schema":
      return !1;

     default:
      return r && "SCALAR" === e.kind || i && "ENUM" === e.kind || p && "INPUT_OBJECT" === e.kind || "OBJECT" === e.kind || "INTERFACE" === e.kind || "UNION" === e.kind;
    }
  })).map(minifyIntrospectionType);
  var y = (o || []).map((function(e) {
    return {
      name: e.name,
      isRepeatable: e.isRepeatable ? !0 : void 0,
      locations: e.locations,
      args: e.args.map((function(e) {
        return {
          name: e.name,
          type: mapType(e.type),
          defaultValue: e.defaultValue || void 0
        };
      }))
    };
  }));
  if (!r || !i || !p || s) {
    d.push({
      kind: "SCALAR",
      name: c.name
    });
  }
  return {
    __schema: {
      queryType: t,
      mutationType: u,
      subscriptionType: m,
      types: d,
      directives: n.includeDirectives ? y : []
    }
  };
}

export { getIntrospectedSchema, minifyIntrospectionQuery };
//# sourceMappingURL=urql-introspection.mjs.map
